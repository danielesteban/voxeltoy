!function(){"use strict";function e(){}function t(e){return e()}function n(){return Object.create(null)}function r(e){e.forEach(t)}function o(e){return"function"==typeof e}function i(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e}let s,a;function c(e,t){return s||(s=document.createElement("a")),s.href=t,e===s.href}function l(t,...n){if(null==t)return e;const r=t.subscribe(...n);return r.unsubscribe?()=>r.unsubscribe():r}function u(e){let t;return l(e,(e=>t=e))(),t}function f(e,t,n){e.$$.on_destroy.push(l(t,n))}function d(e,t,n,r){if(e){const o=p(e,t,n,r);return e[0](o)}}function p(e,t,n,r){return e[1]&&r?function(e,t){for(const n in t)e[n]=t[n];return e}(n.ctx.slice(),e[1](r(t))):n.ctx}function v(e,t,n,r){if(e[2]&&r){const o=e[2](r(n));if(void 0===t.dirty)return o;if("object"==typeof o){const e=[],n=Math.max(t.dirty.length,o.length);for(let r=0;r<n;r+=1)e[r]=t.dirty[r]|o[r];return e}return t.dirty|o}return t.dirty}function h(e,t,n,r,o,i){if(o){const s=p(t,n,r,i);e.p(s,o)}}function m(e){if(e.ctx.length>32){const t=[],n=e.ctx.length/32;for(let e=0;e<n;e++)t[e]=-1;return t}return-1}function x(e,t,n){return e.set(n),t}function g(e,t){e.appendChild(t)}function y(e,t,n){e.insertBefore(t,n||null)}function b(e){e.parentNode.removeChild(e)}function w(e,t){for(let n=0;n<e.length;n+=1)e[n]&&e[n].d(t)}function z(e){return document.createElement(e)}function $(e){return document.createTextNode(e)}function k(){return $(" ")}function S(e,t,n,r){return e.addEventListener(t,n,r),()=>e.removeEventListener(t,n,r)}function T(e,t,n){null==n?e.removeAttribute(t):e.getAttribute(t)!==n&&e.setAttribute(t,n)}function E(e,t){t=""+t,e.wholeText!==t&&(e.data=t)}function C(e,t){e.value=null==t?"":t}function M(e,t,n,r){null===n?e.style.removeProperty(t):e.style.setProperty(t,n,r?"important":"")}function _(e,t,n){e.classList[n?"add":"remove"](t)}function P(e){a=e}function A(){if(!a)throw new Error("Function called outside component initialization");return a}function B(e){A().$$.on_mount.push(e)}function U(e){A().$$.on_destroy.push(e)}function L(){const e=A();return(t,n,{cancelable:r=!1}={})=>{const o=e.$$.callbacks[t];if(o){const i=function(e,t,{bubbles:n=!1,cancelable:r=!1}={}){const o=document.createEvent("CustomEvent");return o.initCustomEvent(e,n,r,t),o}(t,n,{cancelable:r});return o.slice().forEach((t=>{t.call(e,i)})),!i.defaultPrevented}return!0}}const R=[],j=[],N=[],I=[],G=Promise.resolve();let V=!1;function D(){V||(V=!0,G.then(X))}function O(){return D(),G}function F(e){N.push(e)}const q=new Set;let Y=0;function X(){const e=a;do{for(;Y<R.length;){const e=R[Y];Y++,P(e),W(e.$$)}for(P(null),R.length=0,Y=0;j.length;)j.pop()();for(let e=0;e<N.length;e+=1){const t=N[e];q.has(t)||(q.add(t),t())}N.length=0}while(R.length);for(;I.length;)I.pop()();V=!1,q.clear(),P(e)}function W(e){if(null!==e.fragment){e.update(),r(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(F)}}const Z=new Set;let H;function J(){H={r:0,c:[],p:H}}function K(){H.r||r(H.c),H=H.p}function Q(e,t){e&&e.i&&(Z.delete(e),e.i(t))}function ee(e,t,n,r){if(e&&e.o){if(Z.has(e))return;Z.add(e),H.c.push((()=>{Z.delete(e),r&&(n&&e.d(1),r())})),e.o(t)}else r&&r()}const te="undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;function ne(e,t){e.d(1),t.delete(e.key)}function re(e){e&&e.c()}function oe(e,n,i,s){const{fragment:a,on_mount:c,on_destroy:l,after_update:u}=e.$$;a&&a.m(n,i),s||F((()=>{const n=c.map(t).filter(o);l?l.push(...n):r(n),e.$$.on_mount=[]})),u.forEach(F)}function ie(e,t){const n=e.$$;null!==n.fragment&&(r(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function se(t,o,i,s,c,l,u,f=[-1]){const d=a;P(t);const p=t.$$={fragment:null,ctx:null,props:l,update:e,not_equal:c,bound:n(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(o.context||(d?d.$$.context:[])),callbacks:n(),dirty:f,skip_bound:!1,root:o.target||d.$$.root};u&&u(p.root);let v=!1;if(p.ctx=i?i(t,o.props||{},((e,n,...r)=>{const o=r.length?r[0]:n;return p.ctx&&c(p.ctx[e],p.ctx[e]=o)&&(!p.skip_bound&&p.bound[e]&&p.bound[e](o),v&&function(e,t){-1===e.$$.dirty[0]&&(R.push(e),D(),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}(t,e)),n})):[],p.update(),v=!0,r(p.before_update),p.fragment=!!s&&s(p.ctx),o.target){if(o.hydrate){const e=function(e){return Array.from(e.childNodes)}(o.target);p.fragment&&p.fragment.l(e),e.forEach(b)}else p.fragment&&p.fragment.c();o.intro&&Q(t.$$.fragment),oe(t,o.target,o.anchor,o.customElement),X()}P(d)}class ae{$destroy(){ie(this,1),this.$destroy=e}$on(e,t){const n=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return n.push(t),()=>{const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}$set(e){var t;this.$$set&&(t=e,0!==Object.keys(t).length)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}const ce=[];function le(t,n=e){let r;const o=new Set;function s(e){if(i(t,e)&&(t=e,r)){const e=!ce.length;for(const e of o)e[1](),ce.push(e,t);if(e){for(let e=0;e<ce.length;e+=2)ce[e][0](ce[e+1]);ce.length=0}}}return{set:s,update:function(e){s(e(t))},subscribe:function(i,a=e){const c=[i,a];return o.add(c),1===o.size&&(r=n(s)||e),i(t),()=>{o.delete(c),0===o.size&&(r(),r=null)}}}}var ue="// Atlas compute pass\n\n// Noise functions\n// noise3(p: vec3<f32>) -> f32\n// simplexNoise3(v: vec3<f32>) -> f32\n\n// Color helpers\n// hsl2Rgba(h : f32, s: f32, l: f32) -> vec4<f32>\n\n// Constants\n// atlas.count : i32\n// atlas.width : i32\n// atlas.height : i32\n\nfn getColorAt(texture : i32, pixel : vec2<i32>) -> vec4<f32> {\n  var h : f32 = f32(texture) / f32(atlas.count);\n  var s : f32 = 0.5;\n  var l : f32 = 0.5;\n  if (\n    pixel.x == 0 || pixel.x == (atlas.width - 1)\n    || pixel.y == 0 || pixel.y == (atlas.height - 1)\n  ) {\n    l = min(l * 1.1, 1);\n  }\n  return hsl2Rgba(h, s, l);\n}\n",fe="// Effect pass\n\n// Textures\n// var colorTexture : texture_2d<f32>;\n// R G B\n\n// var normalTexture : texture_2d<f32>;\n// X Y Z\n\n// var positionTexture : texture_2d<f32>;\n// X Y Z : world position\n// W : view depth\n\n// Constants\n// camera.position : vec3<f32>\n// camera.direction : vec3<f32>\n\nstruct Effect {\n  color : vec3<f32>,\n  intensity : f32,\n  depthScale : f32,\n  normalScale : f32,\n}\n\nconst effect : Effect = Effect(\n  vec3<f32>(0, 0, 0),\n  0.3,\n  0.5,\n  0.5,\n);\n\nconst offset : vec3<i32> = vec3<i32>(1, 1, 0);\n\nfn edgesDepth(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : f32 = textureLoad(positionTexture, pixel, 0).w;\n  var pixelLeft : f32 = textureLoad(positionTexture, pixel - offset.xz, 0).w;\n  var pixelRight : f32 = textureLoad(positionTexture, pixel + offset.xz, 0).w;\n  var pixelUp : f32 = textureLoad(positionTexture, pixel + offset.zy, 0).w;\n  var pixelDown : f32 = textureLoad(positionTexture, pixel - offset.zy, 0).w;\n  return (\n    abs(pixelLeft    - pixelCenter) \n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter) \n  ) * effect.depthScale;\n}\n\nfn edgesNormal(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : vec3<f32> = textureLoad(normalTexture, pixel, 0).xyz;\n  var pixelLeft : vec3<f32> = textureLoad(normalTexture, pixel - offset.xz, 0).xyz;\n  var pixelRight : vec3<f32> = textureLoad(normalTexture, pixel + offset.xz, 0).xyz;\n  var pixelUp : vec3<f32> = textureLoad(normalTexture, pixel + offset.zy, 0).xyz;\n  var pixelDown : vec3<f32> = textureLoad(normalTexture, pixel - offset.zy, 0).xyz;\n  var edge : vec3<f32> = (\n    abs(pixelLeft    - pixelCenter)\n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter)\n  );\n  return (edge.x + edge.y + edge.z) * effect.normalScale;\n}\n\nfn getColor(pixel : vec2<i32>, size : vec2<i32>, camera : Camera, time : f32) -> vec4<f32> {\n  var color : vec3<f32> = textureLoad(colorTexture, pixel, 0).xyz;\n  color = mix(color, effect.color, clamp(max(edgesDepth(pixel), edgesNormal(pixel)), 0, 1) * effect.intensity);\n  return vec4<f32>(color, 1);\n}\n";const de=["// VoxelToy\n\n// SDF primitives\n// sdBox(p : vec3<f32>, r : vec3<f32>) -> f32\n// sdCapsule(p : vec3<f32>, r : vec2<f32>) -> f32\n// sdEllipsoid(p : vec3<f32>, r : vec3<f32>) -> f32\n// sdSphere(p : vec3<f32>, r : f32) -> f32\n// sdTorus(p : vec3<f32>, r : vec2<f32>) -> f32\n\n// SDF operations\n// opUnion(d1 : f32, d2 : f32) -> f32\n// opSubstraction(d1 : f32, d2 : f32) -> f32\n// opSmoothUnion(d1 : f32, d2 : f32, k : f32) -> f32\n// opSmoothSubstraction(d1 : f32, d2 : f32, k : f32) -> f32\n\n// Noise functions\n// noise3(p: vec3<f32>) -> f32\n// simplexNoise3(v: vec3<f32>) -> f32\n\n// Rotation helpers\n// rotateX(rad : f32) -> mat3x3<f32>\n// rotateY(rad : f32) -> mat3x3<f32>\n// rotateZ(rad : f32) -> mat3x3<f32>\n\n// Constants\n// volume.size : vec3<f32>\n// volume.center : vec3<f32>\n\nfn distanceToScene(pos : vec3<f32>, time : f32) -> f32 {\n  var origin : vec3<f32> = pos - volume.center;\n  var t : f32 = sin(time * 2);\n  var size : f32 = volume.size.x * (0.25 + t * 0.01);\n  return opSmoothUnion(\n    sdSphere(origin - vec3<f32>(size * (0.6 * t * -1), size * 0.2 * t * -1, 0), size),\n    sdSphere(origin - vec3<f32>(size * (0.6 * t), size * 0.2 * t, 0), size),\n    10\n  );\n}\n\nfn getValueAt(pos : vec3<f32>, time : f32) -> f32 {\n  if (distanceToScene(pos, time) > 0.01) {\n    return 0;\n  }\n  return 1 + abs(simplexNoise3(pos * 0.01)) * 254;\n}\n","fn distanceToScene(pos : vec3<f32>, time : f32) -> f32 {\n  var origin : vec3<f32> = pos - volume.center;\n  var r : mat3x3<f32> = rotateX(PI * -0.5);\n  return opUnion(\n    sdTorus(\n      r * origin,\n      vec2<f32>(volume.size.x * 0.3, volume.size.x * 0.1)\n    ),\n    sdTorus(\n      r * rotateY(time) * origin,\n      vec2<f32>(volume.size.x * 0.1, volume.size.x * (0.02 + sin(time * 10) * 0.01))\n    )\n  );\n}\n\nfn getValueAt(pos : vec3<f32>, time : f32) -> f32 {\n  if (distanceToScene(pos, time) > 0.01) {\n    return 0;\n  }\n  return 1 + abs(simplexNoise3(pos * 0.01)) * 254;\n}\n","fn getValueAt(pos : vec3<f32>, time : f32) -> f32 {\n  var p : vec3<f32> = pos + vec3<f32>(0, 0, round(time * 100));\n  var h : f32 = abs(simplexNoise3(p * 0.01)) * volume.size.y;\n  if (pos.y > h) {\n    return 0;\n  }\n  return 1 + abs(simplexNoise3(p * -0.001)) * 254;\n}\n","fn distanceToScene(pos : vec3<f32>, time : f32) -> f32 {\n  if (sdSphere(pos - volume.center, volume.size.x * 0.35) > 0.01) {\n    return 1;\n  }\n  var id : f32 = noise3(floor(pos / 32));\n  var p : vec3<f32> = (pos % 32) - 16;\n  var t : f32 = sin((time + id) * 4);\n  var d : f32;\n  if (floor(id * 10) % 2 == 0) {\n    d = sdSphere(p, t * 4 + 8);\n  } else {\n    d = sdBox(p, vec3<f32>(t * 4 + 8));\n  }\n  return opSmoothSubstraction(\n    opSmoothSubstraction(\n      d,\n      sdBox(p, vec3<f32>(4, 4, 12)),\n      1\n    ),\n    sdBox(p, vec3<f32>(12, 4, 4)),\n    1\n  );\n}\n\nfn getValueAt(pos : vec3<f32>, time : f32) -> f32 {\n  if (distanceToScene(pos, time) > 0.01) {\n    return 0;\n  }\n  return 1 + abs(simplexNoise3(floor(pos / 32))) * 254;\n}\n"],pe={id:le(""),author:le(""),title:le("Untitled"),hasModified:le(!1)},ve=e=>{const{subscribe:t,set:n}=le(e);return{subscribe:t,set(e){pe.hasModified.set(!0),n(e)}}},he={errors:le([]),source:ve(de[0])},me={errors:le([]),source:ve(ue)},xe={errors:le([]),source:ve(fe)},ge={background:ve("#000000"),gpu:null,resolution:ve(200)},ye=e=>{delete he.editor,he.source.set(e.scene),delete me.editor,me.source.set(e.atlas||ue),delete xe.editor,xe.source.set(e.effect||fe),ge.background.set(`#${("000000"+(e.background||0).toString(16)).slice(-6)}`),ge.resolution.set(e.resolution||200),pe.id.set(e.id||""),pe.author.set(e.author||""),pe.title.set(e.title||"Untitled"),pe.hasModified.set(!1)},be=()=>({scene:u(he.source),atlas:u(me.source),effect:u(xe.source),background:parseInt(u(ge.background).slice(1),16),resolution:u(ge.resolution),title:u(pe.title)}),we="https://voxeltoy-server.gatunes.com/",ze=({body:e,endpoint:t,method:n="GET",session:r,signal:o})=>{let i;return!e||e instanceof FormData||(i="application/json",e=JSON.stringify(e)),fetch(`${we}${t}`,{headers:{...r?{Authorization:`Bearer ${r}`}:{},...i?{"Content-Type":i}:{}},body:e,method:n,signal:o}).then((e=>{const{status:t}=e;if(t<200||t>=400)throw new Error(t);return 0===(e.headers.get("content-type")||"").indexOf("application/json")?e.json():e.arrayBuffer()}))},$e=(()=>{const e="voxeltoy:session";let t=localStorage.getItem(e)||!1;if(t)try{t=JSON.parse(t)}catch(e){t=!1}const{subscribe:n,set:r}=le(t),o=t=>{r(t),t?localStorage.setItem(e,JSON.stringify(t)):localStorage.removeItem(e)};return t&&ze({endpoint:"user",session:t.session}).then(o).catch((()=>o(!1))),{subscribe:n,set:o}})(),ke={create:e=>ze({body:e,endpoint:"scene",method:"POST",session:u($e).session}),load:(e,t)=>ze({endpoint:`scene/${e}`,method:"GET",signal:t}),list:(e,t,n)=>ze({endpoint:`scenes/${e}/${t}`,method:"GET",signal:n}),update:(e,t)=>ze({body:t,endpoint:`scene/${e}`,method:"PUT",session:u($e).session})},Se={login:({email:e,password:t})=>ze({body:{email:e,password:t},endpoint:"user",method:"PUT"}).then((e=>$e.set(e))),logout(){$e.set(!1)},register:({email:e,name:t,password:n})=>ze({body:{email:e,name:t,password:n},endpoint:"user",method:"POST"}).then((e=>$e.set(e)))},Te=le({id:"scene"});let Ee;Te.subscribe((e=>{Ee=e}));let Ce=!1;const Me=()=>{Ce&&(Ce.abort(),Ce=!1);const[e,...t]=location.hash.slice(2).split("/");if("gallery"!==e)return e?(Ce=new AbortController,ke.load(e,Ce.signal).then((e=>{Ce=!1,ye(e),Te.set({id:"scene"})})).catch((e=>{"AbortError"!==e.name&&(Ce=!1,location.hash="/")}))):void("gallery"===Ee.id&&Te.set({id:"scene"}));Te.set({id:"gallery",filter:t[0]||"latest"})},_e=(e,t=!1)=>{e!==location.hash.slice(1)?location.hash=e:t&&Me()};function Pe(e,t,n){const r=e.slice();return r[11]=t[n].lineNum,r[12]=t[n].linePos,r[13]=t[n].type,r[14]=t[n].message,r[15]=t[n].line,r[16]=t[n].pointer,r}function Ae(e){let t,n,r,o,i,s,a,c,l,u,f,d,p,v,h,m,x,w=e[11]+"",S=e[12]+"",C=e[13]+"",M=e[14]+"",_=e[15]+"",P=e[16]+"";return{c(){t=z("div"),n=z("div"),r=$(":"),o=$(w),i=$(":"),s=$(S),a=k(),c=$(C),l=$(": "),u=$(M),f=k(),d=z("div"),p=$(_),v=k(),h=z("div"),m=$(P),x=k(),T(n,"class","svelte-nhmndz"),T(d,"class","svelte-nhmndz"),T(h,"class","svelte-nhmndz"),T(t,"class","svelte-nhmndz")},m(e,b){y(e,t,b),g(t,n),g(n,r),g(n,o),g(n,i),g(n,s),g(n,a),g(n,c),g(n,l),g(n,u),g(t,f),g(t,d),g(d,p),g(t,v),g(t,h),g(h,m),g(t,x)},p(e,t){4&t&&w!==(w=e[11]+"")&&E(o,w),4&t&&S!==(S=e[12]+"")&&E(s,S),4&t&&C!==(C=e[13]+"")&&E(c,C),4&t&&M!==(M=e[14]+"")&&E(u,M),4&t&&_!==(_=e[15]+"")&&E(p,_),4&t&&P!==(P=e[16]+"")&&E(m,P)},d(e){e&&b(t)}}}function Be(t){let n,r,o,i,s,a,c,l,u,f,d,p,v,h,m=t[2].length+"",x=t[2],C=[];for(let e=0;e<x.length;e+=1)C[e]=Ae(Pe(t,x,e));return{c(){n=z("div"),r=z("div"),o=k(),i=z("div"),s=z("div"),a=z("div"),c=k(),l=$(m),u=$(" errors\n      "),f=z("div"),d=k(),p=z("div");for(let e=0;e<C.length;e+=1)C[e].c();T(r,"class","wrapper svelte-nhmndz"),T(a,"class","status svelte-nhmndz"),_(a,"error",t[2].length),T(f,"class","arrow svelte-nhmndz"),T(s,"class","toggle svelte-nhmndz"),T(p,"class","messages svelte-nhmndz"),T(i,"class","errors svelte-nhmndz"),_(i,"open",t[1]),T(n,"class","editor svelte-nhmndz")},m(e,m){y(e,n,m),g(n,r),t[7](r),g(n,o),g(n,i),g(i,s),g(s,a),g(s,c),g(s,l),g(s,u),g(s,f),g(i,d),g(i,p);for(let e=0;e<C.length;e+=1)C[e].m(p,null);v||(h=S(s,"click",t[5]),v=!0)},p(e,[t]){if(4&t&&_(a,"error",e[2].length),4&t&&m!==(m=e[2].length+"")&&E(l,m),4&t){let n;for(x=e[2],n=0;n<x.length;n+=1){const r=Pe(e,x,n);C[n]?C[n].p(r,t):(C[n]=Ae(r),C[n].c(),C[n].m(p,null))}for(;n<C.length;n+=1)C[n].d(1);C.length=x.length}2&t&&_(i,"open",e[1])},i:e,o:e,d(e){e&&b(n),t[7](null),w(C,e),v=!1,h()}}}function Ue(e,t,n){let r,o,{state:i}=t;const{errors:s,source:a}=i;let c,l;f(e,s,(e=>n(2,o=e))),f(e,a,(e=>n(9,r=e)));let u=!1;const d=()=>l.layout();return B((()=>{let e,t=!0,o=!1;if(l=monaco.editor.create(c,{minimap:{enabled:!1},theme:"vs-dark"}),i.editor){const{model:e,view:t}=i.editor;l.setModel(e),l.restoreViewState(t)}else l.setModel(monaco.editor.createModel(r,"c"));const u=[s.subscribe((e=>{monaco.editor.setModelMarkers(l.getModel(),"Errors",e.map((({lineNum:e,linePos:t,length:n,message:r})=>({message:r,startLineNumber:e,endLineNumber:e,startColumn:t,endColumn:t+n}))))})),a.subscribe((e=>{t||(o=!0,l.setValue(e),o=!1)}))];return t=!1,l.onDidChangeModelContent((()=>{o||(e&&clearTimeout(e),e=setTimeout((()=>{t=!0,a.set(l.getValue()),t=!1}),300))})),l.focus(),window.addEventListener("resize",d,!1),()=>{n(6,i.editor={model:l.getModel(),view:l.saveViewState()},i),l.dispose(),clearTimeout(e),window.removeEventListener("resize",d),u.forEach((e=>e()))}})),e.$$set=e=>{"state"in e&&n(6,i=e.state)},[c,u,o,s,a,()=>{n(1,u=!u),O().then(d)},i,function(e){j[e?"unshift":"push"]((()=>{c=e,n(0,c)}))}]}class Le extends ae{constructor(e){super(),se(this,e,Ue,Be,i,{state:6})}}function Re(t){let n,r;return n=new Le({props:{state:me}}),{c(){re(n.$$.fragment)},m(e,t){oe(n,e,t),r=!0},p:e,i(e){r||(Q(n.$$.fragment,e),r=!0)},o(e){ee(n.$$.fragment,e),r=!1},d(e){ie(n,e)}}}class je extends ae{constructor(e){super(),se(this,e,null,Re,i,{})}}function Ne(t){let n,r;return n=new Le({props:{state:xe}}),{c(){re(n.$$.fragment)},m(e,t){oe(n,e,t),r=!0},p:e,i(e){r||(Q(n.$$.fragment,e),r=!0)},o(e){ee(n.$$.fragment,e),r=!1},d(e){ie(n,e)}}}class Ie extends ae{constructor(e){super(),se(this,e,null,Ne,i,{})}}function Ge(e){let t;const n=e[4].default,r=d(n,e,e[3],null);return{c(){r&&r.c()},m(e,n){r&&r.m(e,n),t=!0},p(e,o){r&&r.p&&(!t||8&o)&&h(r,n,e,e[3],t?v(n,e[3],o,null):m(e[3]),null)},i(e){t||(Q(r,e),t=!0)},o(e){ee(r,e),t=!1},d(e){r&&r.d(e)}}}function Ve(e){let t,n,r=e[1]&&Ge(e);return{c(){t=z("div"),r&&r.c(),T(t,"class","wrapper svelte-1o8k14a")},m(o,i){y(o,t,i),r&&r.m(t,null),e[5](t),n=!0},p(e,[n]){e[1]?r?(r.p(e,n),2&n&&Q(r,1)):(r=Ge(e),r.c(),Q(r,1),r.m(t,null)):r&&(J(),ee(r,1,1,(()=>{r=null})),K())},i(e){n||(Q(r),n=!0)},o(e){ee(r),n=!1},d(n){n&&b(t),r&&r.d(),e[5](null)}}}function De(e,t,n){let{$$slots:r={},$$scope:o}=t,{enabled:i=!0}=t,s=!1;const a=setTimeout((()=>{n(1,s=!0)}),100),c=L(),l=new IntersectionObserver((([{isIntersecting:e}])=>{e&&c("intersect")}));let u;return U((()=>{clearTimeout(a),l.disconnect()})),e.$$set=e=>{"enabled"in e&&n(2,i=e.enabled),"$$scope"in e&&n(3,o=e.$$scope)},e.$$.update=()=>{5&e.$$.dirty&&(i?l.observe(u):l.disconnect())},[u,s,i,o,r,function(e){j[e?"unshift":"push"]((()=>{u=e,n(0,u)}))}]}class Oe extends ae{constructor(e){super(),se(this,e,De,Ve,i,{enabled:2})}}function Fe(e,t,n){const r=e.slice();return r[6]=t[n].id,r[7]=t[n].author,r[8]=t[n].title,r}function qe(e,t){let n,r,i,s,a,l,u,f,d,p,v,h,m,x=t[8]+"",w=t[7]+"";return{key:e,first:null,c(){n=z("div"),r=z("img"),a=k(),l=z("div"),u=$(x),f=k(),d=z("span"),p=$("by "),v=$(w),T(r,"alt",i=t[8]),T(r,"crossorigin","anonymous"),c(r.src,s=we+"scene/"+t[6]+"/screenshot")||T(r,"src",s),T(r,"class","svelte-1wtwusb"),T(d,"class","svelte-1wtwusb"),T(l,"class","svelte-1wtwusb"),T(n,"class","item svelte-1wtwusb"),this.first=n},m(e,i){y(e,n,i),g(n,r),g(n,a),g(n,l),g(l,u),g(l,f),g(l,d),g(d,p),g(d,v),h||(m=S(n,"click",(function(){o(t[5](t[6]))&&t[5](t[6]).apply(this,arguments)})),h=!0)},p(e,n){t=e,2&n&&i!==(i=t[8])&&T(r,"alt",i),2&n&&!c(r.src,s=we+"scene/"+t[6]+"/screenshot")&&T(r,"src",s),2&n&&x!==(x=t[8]+"")&&E(u,x),2&n&&w!==(w=t[7]+"")&&E(v,w)},d(e){e&&b(n),h=!1,m()}}}function Ye(e){let t,n;return t=new Oe({props:{enabled:!!e[3],$$slots:{default:[Xe]},$$scope:{ctx:e}}}),t.$on("intersect",(function(){o(e[4](e[0].filter,e[3]))&&e[4](e[0].filter,e[3]).apply(this,arguments)})),{c(){re(t.$$.fragment)},m(e,r){oe(t,e,r),n=!0},p(n,r){e=n;const o={};8&r&&(o.enabled=!!e[3]),2048&r&&(o.$$scope={dirty:r,ctx:e}),t.$set(o)},i(e){n||(Q(t.$$.fragment,e),n=!0)},o(e){ee(t.$$.fragment,e),n=!1},d(e){ie(t,e)}}}function Xe(e){let t;return{c(){t=$("Loading...")},m(e,n){y(e,t,n)},d(e){e&&b(t)}}}function We(e){let t,n,r,o=[],i=new Map,s=e[1];const a=e=>e[6];for(let t=0;t<s.length;t+=1){let n=Fe(e,s,t),r=a(n);i.set(r,o[t]=qe(r,n))}let c=(e[2]||e[3])&&Ye(e);return{c(){t=z("div");for(let e=0;e<o.length;e+=1)o[e].c();n=k(),c&&c.c(),T(t,"class","wrapper svelte-1wtwusb")},m(e,i){y(e,t,i);for(let e=0;e<o.length;e+=1)o[e].m(t,null);g(t,n),c&&c.m(t,null),r=!0},p(e,[r]){34&r&&(s=e[1],o=function(e,t,n,r,o,i,s,a,c,l,u,f){let d=e.length,p=i.length,v=d;const h={};for(;v--;)h[e[v].key]=v;const m=[],x=new Map,g=new Map;for(v=p;v--;){const e=f(o,i,v),a=n(e);let c=s.get(a);c?r&&c.p(e,t):(c=l(a,e),c.c()),x.set(a,m[v]=c),a in h&&g.set(a,Math.abs(v-h[a]))}const y=new Set,b=new Set;function w(e){Q(e,1),e.m(a,u),s.set(e.key,e),u=e.first,p--}for(;d&&p;){const t=m[p-1],n=e[d-1],r=t.key,o=n.key;t===n?(u=t.first,d--,p--):x.has(o)?!s.has(r)||y.has(r)?w(t):b.has(o)?d--:g.get(r)>g.get(o)?(b.add(r),w(t)):(y.add(o),d--):(c(n,s),d--)}for(;d--;){const t=e[d];x.has(t.key)||c(t,s)}for(;p;)w(m[p-1]);return m}(o,r,a,1,e,s,i,t,ne,qe,n,Fe)),e[2]||e[3]?c?(c.p(e,r),12&r&&Q(c,1)):(c=Ye(e),c.c(),Q(c,1),c.m(t,null)):c&&(J(),ee(c,1,1,(()=>{c=null})),K())},i(e){r||(Q(c),r=!0)},o(e){ee(c),r=!1},d(e){e&&b(t);for(let e=0;e<o.length;e+=1)o[e].d();c&&c.d()}}}function Ze(e,t,n){let r;f(e,Te,(e=>n(0,r=e)));let o=[],i=!1,s=!1;const a=(e,t)=>()=>{i&&i.abort(),n(2,i=new AbortController),n(3,s=!1),ke.list(e,t,i.signal).then((({pages:e,scenes:r})=>{n(1,o=t>0?[...o,...r]:r),n(3,s=t<e-1&&t+1)})).catch((()=>{})).finally((()=>{n(2,i=!1)}))};U((()=>{i&&i.abort()}));return e.$$.update=()=>{1&e.$$.dirty&&a(r.filter,0)()},[r,o,i,s,a,e=>()=>{location.hash=`/${e}`}]}class He extends ae{constructor(e){super(),se(this,e,Ze,We,i,{})}}function Je(e){let t,n,r,o,i,s;return{c(){t=z("div"),n=z("label"),n.textContent="Name:",r=k(),o=z("input"),T(n,"for","name"),T(n,"class","svelte-sr2txy"),T(o,"autocomplete","off"),T(o,"id","name"),T(o,"type","text"),o.required=!0,T(o,"class","svelte-sr2txy"),T(t,"class","input svelte-sr2txy")},m(a,c){y(a,t,c),g(t,n),g(t,r),g(t,o),C(o,e[1]),i||(s=S(o,"input",e[10]),i=!0)},p(e,t){2&t&&o.value!==e[1]&&C(o,e[1])},d(e){e&&b(t),i=!1,s()}}}function Ke(e){let t;return{c(){t=z("div"),t.textContent="There was an error",T(t,"class","error svelte-sr2txy")},m(e,n){y(e,t,n)},d(e){e&&b(t)}}}function Qe(e){let t;return{c(){t=$("Login")},m(e,n){y(e,t,n)},d(e){e&&b(t)}}}function et(e){let t;return{c(){t=$("Register")},m(e,n){y(e,t,n)},d(e){e&&b(t)}}}function tt(t){let n,r,o;return{c(){n=z("a"),n.textContent="Need an account?",T(n,"class","svelte-sr2txy")},m(e,i){y(e,n,i),r||(o=S(n,"click",t[8]),r=!0)},p:e,d(e){e&&b(n),r=!1,o()}}}function nt(t){let n,r,o;return{c(){n=z("a"),n.textContent="Already have an account?",T(n,"class","svelte-sr2txy")},m(e,i){y(e,n,i),r||(o=S(n,"click",t[6]),r=!0)},p:e,d(e){e&&b(n),r=!1,o()}}}function rt(t){let n,i,s,a,c,l,u,f,d,p,v,h,m,x,w,$,E,M,_,P,A=t[5]&&Je(t),B=t[3]&&Ke();function U(e,t){return e[5]?et:Qe}let L=U(t),R=L(t);function j(e,t){return e[5]?nt:tt}let N=j(t),I=N(t);return{c(){n=z("form"),A&&A.c(),i=k(),s=z("div"),a=z("label"),a.textContent="Email:",c=k(),l=z("input"),u=k(),f=z("div"),d=z("label"),d.textContent="Password:",p=k(),v=z("input"),m=k(),B&&B.c(),x=k(),w=z("div"),$=z("button"),R.c(),E=k(),M=z("div"),I.c(),T(a,"for","email"),T(a,"class","svelte-sr2txy"),T(l,"autocomplete","username"),T(l,"id","email"),T(l,"type","email"),l.required=!0,T(l,"class","svelte-sr2txy"),T(s,"class","input svelte-sr2txy"),T(d,"for","password"),T(d,"class","svelte-sr2txy"),T(v,"autocomplete",h=t[5]?"current-password":"new-password"),T(v,"id","password"),T(v,"type","password"),v.required=!0,T(v,"class","svelte-sr2txy"),T(f,"class","input svelte-sr2txy"),T($,"type","submit"),$.disabled=t[4],T(w,"class","submit svelte-sr2txy"),T(M,"class","alternative svelte-sr2txy"),T(n,"class","svelte-sr2txy")},m(e,r){y(e,n,r),A&&A.m(n,null),g(n,i),g(n,s),g(s,a),g(s,c),g(s,l),C(l,t[0]),g(n,u),g(n,f),g(f,d),g(f,p),g(f,v),C(v,t[2]),g(n,m),B&&B.m(n,null),g(n,x),g(n,w),g(w,$),R.m($,null),g(n,E),g(n,M),I.m(M,null),_||(P=[S(l,"input",t[11]),S(v,"input",t[12]),S(n,"submit",(function(){o(t[5]?t[9]:t[7])&&(t[5]?t[9]:t[7]).apply(this,arguments)}))],_=!0)},p(e,[r]){(t=e)[5]?A?A.p(t,r):(A=Je(t),A.c(),A.m(n,i)):A&&(A.d(1),A=null),1&r&&l.value!==t[0]&&C(l,t[0]),32&r&&h!==(h=t[5]?"current-password":"new-password")&&T(v,"autocomplete",h),4&r&&v.value!==t[2]&&C(v,t[2]),t[3]?B||(B=Ke(),B.c(),B.m(n,x)):B&&(B.d(1),B=null),L!==(L=U(t))&&(R.d(1),R=L(t),R&&(R.c(),R.m($,null))),16&r&&($.disabled=t[4]),N===(N=j(t))&&I?I.p(t,r):(I.d(1),I=N(t),I&&(I.c(),I.m(M,null)))},i:e,o:e,d(e){e&&b(n),A&&A.d(),B&&B.d(),R.d(),I.d(),_=!1,r(P)}}}function ot(e,t,n){let r="",o="",i="",s=!1,a=!1,c=!1;return[r,o,i,s,a,c,()=>{n(5,c=!1)},e=>{e.preventDefault(),n(3,s=!1),n(4,a=!0),Se.login({email:r,password:i}).catch((()=>{n(3,s=!0)})).finally((()=>{n(4,a=!1)}))},()=>{n(5,c=!0)},e=>{e.preventDefault(),n(3,s=!1),n(4,a=!0),Se.register({email:r,name:o,password:i}).catch((()=>{n(3,s=!0)})).finally((()=>{n(4,a=!1)}))},function(){o=this.value,n(1,o)},function(){r=this.value,n(0,r)},function(){i=this.value,n(2,i)}]}class it extends ae{constructor(e){super(),se(this,e,ot,rt,i,{})}}function st(t){let n,r;return n=new it({}),{c(){re(n.$$.fragment)},m(e,t){oe(n,e,t),r=!0},p:e,i(e){r||(Q(n.$$.fragment,e),r=!0)},o(e){ee(n.$$.fragment,e),r=!1},d(e){ie(n,e)}}}function at(t){let n,o,i,s,a,l,u,f,d,p,v,h,m,x,w,E,M,_,P,A,B,U,L,R,j,N=t[7]?"Save":"Publish";return{c(){n=z("form"),o=z("div"),i=z("label"),i.textContent="Author:",s=k(),a=z("input"),u=k(),f=z("div"),d=z("label"),d.textContent="Title:",p=k(),v=z("input"),h=k(),m=z("div"),x=z("label"),w=$("Screenshot:\n          \n          "),E=z("a"),E.textContent="refresh",M=k(),_=z("img"),A=k(),B=z("div"),U=z("button"),L=$(N),T(i,"for","author"),T(i,"class","svelte-uy7wds"),a.value=l=t[2].name,T(a,"autocomplete","off"),T(a,"id","author"),T(a,"type","text"),a.disabled=!0,T(a,"class","svelte-uy7wds"),T(o,"class","input svelte-uy7wds"),T(d,"for","title"),T(d,"class","svelte-uy7wds"),T(v,"autocomplete","off"),T(v,"id","title"),T(v,"type","text"),v.required=!0,T(v,"class","svelte-uy7wds"),T(f,"class","input svelte-uy7wds"),T(E,"class","svelte-uy7wds"),T(x,"for","name"),T(x,"class","svelte-uy7wds"),T(_,"alt","screenshot"),T(_,"crossorigin","anonymous"),c(_.src,P=t[1])||T(_,"src",P),T(_,"class","svelte-uy7wds"),T(m,"class","input screenshot svelte-uy7wds"),T(U,"type","submit"),U.disabled=t[0],T(B,"class","submit svelte-uy7wds"),T(n,"class","svelte-uy7wds")},m(e,r){y(e,n,r),g(n,o),g(o,i),g(o,s),g(o,a),g(n,u),g(n,f),g(f,d),g(f,p),g(f,v),C(v,t[3]),g(n,h),g(n,m),g(m,x),g(x,w),g(x,E),g(m,M),g(m,_),g(n,A),g(n,B),g(B,U),g(U,L),R||(j=[S(v,"input",t[11]),S(E,"click",t[8]),S(n,"submit",t[7]?t[10]:t[9])],R=!0)},p(e,t){4&t&&l!==(l=e[2].name)&&a.value!==l&&(a.value=l),8&t&&v.value!==e[3]&&C(v,e[3]),2&t&&!c(_.src,P=e[1])&&T(_,"src",P),1&t&&(U.disabled=e[0])},i:e,o:e,d(e){e&&b(n),R=!1,r(j)}}}function ct(e){let t,n,r,o;const i=[at,st],s=[];function a(e,t){return e[2]?0:1}return n=a(e),r=s[n]=i[n](e),{c(){t=z("div"),r.c(),T(t,"class","wrapper svelte-uy7wds")},m(e,r){y(e,t,r),s[n].m(t,null),o=!0},p(e,[o]){let c=n;n=a(e),n===c?s[n].p(e,o):(J(),ee(s[c],1,1,(()=>{s[c]=null})),K(),r=s[n],r?r.p(e,o):(r=s[n]=i[n](e),r.c()),Q(r,1),r.m(t,null))},i(e){o||(Q(r),o=!0)},o(e){ee(r),o=!1},d(e){e&&b(t),s[n].d()}}}function lt(e,t,n){let r,o,i,s;f(e,$e,(e=>n(2,o=e)));const{id:a,author:c,title:l}=pe;f(e,a,(e=>n(12,r=e))),f(e,c,(e=>n(13,i=e))),f(e,l,(e=>n(3,s=e)));let u=!1,d=r&&i===o.name,p=d?`${we}scene/${r}/screenshot`:ge.screenshot();const v=()=>"data:"===p.slice(0,5)?p.slice(22):void 0;return[u,p,o,s,a,c,l,d,()=>{n(1,p=ge.screenshot())},e=>{e.preventDefault(),u||(n(0,u=!0),ke.create({...be(),screenshot:v()}).then((e=>_e(`/${e}`))).catch((()=>{})))},e=>{e.preventDefault(),u||(n(0,u=!0),ke.update(r,{...be(),screenshot:v()}).then((e=>_e(`/${e}`,!0))).catch((()=>{})))},function(){s=this.value,l.set(s)}]}class ut extends ae{constructor(e){super(),se(this,e,lt,ct,i,{})}}function ft(e,t,n){const r=e.slice();return r[7]=t[n],r}function dt(e){let t,n,r,o,i,s,a=e[7]+"";return{c(){t=z("div"),n=$(a),r=z("span"),r.textContent="3",o=k(),T(r,"class","svelte-1dla2ul"),T(t,"class","svelte-1dla2ul"),_(t,"enabled",e[7]===e[0])},m(a,c){y(a,t,c),g(t,n),g(t,r),g(t,o),i||(s=S(t,"click",e[5](e[7])),i=!0)},p(n,r){e=n,17&r&&_(t,"enabled",e[7]===e[0])},d(e){e&&b(t),i=!1,s()}}}function pt(t){let n,r,o,i,s,a,c,l,u,f,d,p,v=t[4],h=[];for(let e=0;e<v.length;e+=1)h[e]=dt(ft(t,v,e));return{c(){n=z("div"),r=z("div"),o=z("label"),o.textContent="Background:",i=k(),s=z("input"),a=k(),c=z("div"),l=z("label"),l.textContent="Resolution:",u=k(),f=z("div");for(let e=0;e<h.length;e+=1)h[e].c();T(o,"for","background"),T(o,"class","svelte-1dla2ul"),T(s,"id","background"),T(s,"type","color"),T(s,"class","svelte-1dla2ul"),T(r,"class","input svelte-1dla2ul"),T(l,"for","resolution"),T(l,"class","svelte-1dla2ul"),T(f,"class","resolution svelte-1dla2ul"),T(c,"class","input svelte-1dla2ul"),T(n,"class","wrapper svelte-1dla2ul")},m(e,v){y(e,n,v),g(n,r),g(r,o),g(r,i),g(r,s),C(s,t[1]),g(n,a),g(n,c),g(c,l),g(c,u),g(c,f);for(let e=0;e<h.length;e+=1)h[e].m(f,null);d||(p=S(s,"input",t[6]),d=!0)},p(e,[t]){if(2&t&&C(s,e[1]),49&t){let n;for(v=e[4],n=0;n<v.length;n+=1){const r=ft(e,v,n);h[n]?h[n].p(r,t):(h[n]=dt(r),h[n].c(),h[n].m(f,null))}for(;n<h.length;n+=1)h[n].d(1);h.length=v.length}},i:e,o:e,d(e){e&&b(n),w(h,e),d=!1,p()}}}function vt(e,t,n){let r,o;const{background:i,resolution:s}=ge;f(e,i,(e=>n(1,o=e))),f(e,s,(e=>n(0,r=e)));return[r,o,i,s,[100,200,300,400],e=>()=>{x(s,r=e,r)},function(){o=this.value,i.set(o)}]}class ht extends ae{constructor(e){super(),se(this,e,vt,pt,i,{})}}function mt(t){let n,r;return n=new Le({props:{state:he}}),{c(){re(n.$$.fragment)},m(e,t){oe(n,e,t),r=!0},p:e,i(e){r||(Q(n.$$.fragment,e),r=!0)},o(e){ee(n.$$.fragment,e),r=!1},d(e){ie(n,e)}}}class xt extends ae{constructor(e){super(),se(this,e,null,mt,i,{})}}const gt=e=>({}),yt=e=>({}),bt=e=>({}),wt=e=>({});function zt(e){let t,n,r,o;const i=e[1].toggle,s=d(i,e,e[0],wt),a=e[1].options,c=d(a,e,e[0],yt);return{c(){t=z("div"),s&&s.c(),n=k(),r=z("div"),c&&c.c(),T(r,"class","options svelte-7xzgh1"),T(t,"class","dropdown svelte-7xzgh1")},m(e,i){y(e,t,i),s&&s.m(t,null),g(t,n),g(t,r),c&&c.m(r,null),o=!0},p(e,[t]){s&&s.p&&(!o||1&t)&&h(s,i,e,e[0],o?v(i,e[0],t,bt):m(e[0]),wt),c&&c.p&&(!o||1&t)&&h(c,a,e,e[0],o?v(a,e[0],t,gt):m(e[0]),yt)},i(e){o||(Q(s,e),Q(c,e),o=!0)},o(e){ee(s,e),ee(c,e),o=!1},d(e){e&&b(t),s&&s.d(e),c&&c.d(e)}}}function $t(e,t,n){let{$$slots:r={},$$scope:o}=t;return e.$$set=e=>{"$$scope"in e&&n(0,o=e.$$scope)},[o,r]}class kt extends ae{constructor(e){super(),se(this,e,$t,zt,i,{})}}function St(e,t,n){const r=e.slice();return r[18]=t[n].id,r[22]=t[n].name,r}function Tt(e,t,n){const r=e.slice();return r[25]=t[n],r[27]=n,r}function Et(e){let t,n,r,o,i,s,a,c,l,u,f,d,p,v,h,m,x;function C(e,t){return e[4]||e[5]?_t:Mt}let M=C(e),_=M(e);f=new kt({props:{$$slots:{options:[Lt],toggle:[Pt]},$$scope:{ctx:e}}});let P=e[11],A=[];for(let t=0;t<P.length;t+=1)A[t]=Rt(St(e,P,t));let B=e[6]&&jt(e);return{c(){t=z("div"),n=z("span"),r=z("a"),r.textContent="Voxeltoy",o=$("\n        >"),i=k(),s=$(e[3]),a=$(" by\n      "),_.c(),c=k(),l=z("div"),u=z("div"),re(f.$$.fragment),d=k();for(let e=0;e<A.length;e+=1)A[e].c();p=k(),v=z("div"),B&&B.c(),T(r,"class","svelte-1juovjy"),T(n,"class","parent svelte-1juovjy"),T(t,"class","menu svelte-1juovjy"),T(u,"class","svelte-1juovjy"),T(v,"class","svelte-1juovjy"),T(l,"class","toolbar svelte-1juovjy")},m(b,w){y(b,t,w),g(t,n),g(n,r),g(n,o),g(t,i),g(t,s),g(t,a),_.m(t,null),y(b,c,w),y(b,l,w),g(l,u),oe(f,u,null),g(u,d);for(let e=0;e<A.length;e+=1)A[e].m(u,null);g(l,p),g(l,v),B&&B.m(v,null),h=!0,m||(x=S(r,"click",e[12]()),m=!0)},p(e,n){(!h||8&n)&&E(s,e[3]),M===(M=C(e))&&_?_.p(e,n):(_.d(1),_=M(e),_&&(_.c(),_.m(t,null)));const r={};if(268435696&n&&(r.$$scope={dirty:n,ctx:e}),f.$set(r),18436&n){let t;for(P=e[11],t=0;t<P.length;t+=1){const r=St(e,P,t);A[t]?A[t].p(r,n):(A[t]=Rt(r),A[t].c(),A[t].m(u,null))}for(;t<A.length;t+=1)A[t].d(1);A.length=P.length}e[6]?B?B.p(e,n):(B=jt(e),B.c(),B.m(v,null)):B&&(B.d(1),B=null)},i(e){h||(Q(f.$$.fragment,e),h=!0)},o(e){ee(f.$$.fragment,e),h=!1},d(e){e&&b(t),_.d(),e&&b(c),e&&b(l),ie(f),w(A,e),B&&B.d(),m=!1,x()}}}function Ct(t){let n,r,i,s,a,c,l,u,f="latest"!==t[2].filter&&Gt(t);return{c(){n=z("div"),n.textContent="Voxeltoy",r=k(),i=z("div"),s=z("div"),a=z("div"),a.textContent="Latest",c=k(),f&&f.c(),T(n,"class","menu svelte-1juovjy"),T(a,"class","view svelte-1juovjy"),_(a,"enabled","latest"===t[2].filter),T(s,"class","svelte-1juovjy"),T(i,"class","toolbar svelte-1juovjy")},m(e,d){y(e,n,d),y(e,r,d),y(e,i,d),g(i,s),g(s,a),g(s,c),f&&f.m(s,null),l||(u=S(a,"click",(function(){o("latest"!==t[2].filter?t[12]():null)&&("latest"!==t[2].filter?t[12]():null).apply(this,arguments)})),l=!0)},p(e,n){t=e,4&n&&_(a,"enabled","latest"===t[2].filter),"latest"!==t[2].filter?f?f.p(t,n):(f=Gt(t),f.c(),f.m(s,null)):f&&(f.d(1),f=null)},i:e,o:e,d(e){e&&b(n),e&&b(r),e&&b(i),f&&f.d(),l=!1,u()}}}function Mt(t){let n;return{c(){n=$("anonymous")},m(e,t){y(e,n,t)},p:e,d(e){e&&b(n)}}}function _t(e){let t,n,r,i,s=(e[4]||e[5].name)+"";return{c(){t=z("a"),n=$(s),T(t,"class","svelte-1juovjy")},m(s,a){y(s,t,a),g(t,n),r||(i=S(t,"click",(function(){o(e[12](e[4]||e[5].name))&&e[12](e[4]||e[5].name).apply(this,arguments)})),r=!0)},p(t,r){e=t,48&r&&s!==(s=(e[4]||e[5].name)+"")&&E(n,s)},d(e){e&&b(t),r=!1,i()}}}function Pt(t){let n;return{c(){n=z("div"),n.innerHTML='<div class="arrow svelte-1juovjy"></div>\n            File',T(n,"class","toggle svelte-1juovjy"),T(n,"slot","toggle")},m(e,t){y(e,n,t)},p:e,d(e){e&&b(n)}}}function At(e){let t,n,r,o,i,s=e[27]+1+"";return{c(){t=z("div"),n=$("Example "),r=$(s),T(t,"class","action svelte-1juovjy")},m(s,a){y(s,t,a),g(t,n),g(t,r),o||(i=S(t,"click",e[13](e[25])),o=!0)},p(t,n){e=t},d(e){e&&b(t),o=!1,i()}}}function Bt(e){let t;return{c(){t=$("Publish")},m(e,n){y(e,t,n)},d(e){e&&b(t)}}}function Ut(e){let t;return{c(){t=$("Save")},m(e,n){y(e,t,n)},d(e){e&&b(t)}}}function Lt(e){let t,n,i,s,a,c,l,u,f,d,p,v,h,m,x,E=de,C=[];for(let t=0;t<E.length;t+=1)C[t]=At(Tt(e,E,t));function M(e,t){return e[7]&&e[5]&&e[4]===e[5].name?Ut:Bt}let P=M(e),A=P(e);return{c(){t=z("div"),n=$("Examples\n              "),i=z("div"),s=k(),a=z("div");for(let e=0;e<C.length;e+=1)C[e].c();c=k(),l=z("div"),l.textContent="New",u=k(),f=z("div"),f.textContent="Import",d=k(),p=z("div"),p.textContent="Export",v=k(),h=z("div"),A.c(),T(i,"class","arrow svelte-1juovjy"),T(a,"class","examples svelte-1juovjy"),T(t,"class","load svelte-1juovjy"),T(l,"class","action svelte-1juovjy"),T(f,"class","action svelte-1juovjy"),T(p,"class","action svelte-1juovjy"),T(h,"class","action svelte-1juovjy"),_(h,"disabled",!e[6])},m(r,b){y(r,t,b),g(t,n),g(t,i),g(t,s),g(t,a);for(let e=0;e<C.length;e+=1)C[e].m(a,null);y(r,c,b),y(r,l,b),y(r,u,b),y(r,f,b),y(r,d,b),y(r,p,b),y(r,v,b),y(r,h,b),A.m(h,null),m||(x=[S(l,"click",e[13](de[0])),S(f,"click",e[15]),S(p,"click",e[17]),S(h,"click",(function(){o(e[6]?e[14]("publish"):null)&&(e[6]?e[14]("publish"):null).apply(this,arguments)}))],m=!0)},p(t,n){if(e=t,8192&n){let t;for(E=de,t=0;t<E.length;t+=1){const r=Tt(e,E,t);C[t]?C[t].p(r,n):(C[t]=At(r),C[t].c(),C[t].m(a,null))}for(;t<C.length;t+=1)C[t].d(1);C.length=E.length}P!==(P=M(e))&&(A.d(1),A=P(e),A&&(A.c(),A.m(h,null))),64&n&&_(h,"disabled",!e[6])},d(e){e&&b(t),w(C,e),e&&b(c),e&&b(l),e&&b(u),e&&b(f),e&&b(d),e&&b(p),e&&b(v),e&&b(h),A.d(),m=!1,r(x)}}}function Rt(e){let t,n,r,o,i,s=e[22]+"";return{c(){t=z("div"),n=$(s),r=k(),T(t,"class","view svelte-1juovjy"),_(t,"enabled",e[2].id===e[18])},m(s,a){y(s,t,a),g(t,n),g(t,r),o||(i=S(t,"click",e[14](e[18])),o=!0)},p(n,r){e=n,2052&r&&_(t,"enabled",e[2].id===e[18])},d(e){e&&b(t),o=!1,i()}}}function jt(e){let t,n,r;function o(e,t){return e[7]&&e[5]&&e[4]===e[5].name?It:Nt}let i=o(e),s=i(e);return{c(){t=z("div"),s.c(),T(t,"class","view svelte-1juovjy"),_(t,"enabled","publish"===e[2].id)},m(o,i){y(o,t,i),s.m(t,null),n||(r=S(t,"click",e[14]("publish")),n=!0)},p(e,n){i!==(i=o(e))&&(s.d(1),s=i(e),s&&(s.c(),s.m(t,null))),4&n&&_(t,"enabled","publish"===e[2].id)},d(e){e&&b(t),s.d(),n=!1,r()}}}function Nt(e){let t;return{c(){t=$("Publish")},m(e,n){y(e,t,n)},d(e){e&&b(t)}}}function It(e){let t;return{c(){t=$("Save")},m(e,n){y(e,t,n)},d(e){e&&b(t)}}}function Gt(e){let t,n,r=e[2].filter+"";return{c(){t=z("div"),n=$(r),T(t,"class","view enabled svelte-1juovjy")},m(e,r){y(e,t,r),g(t,n)},p(e,t){4&t&&r!==(r=e[2].filter+"")&&E(n,r)},d(e){e&&b(t)}}}function Vt(e){let t,n,r,o,i,s,a,c,l,u,f;const d=[Ct,Et],p=[];function v(e,t){return"gallery"===e[2].id?0:1}return a=v(e),c=p[a]=d[a](e),{c(){t=z("div"),n=z("input"),r=k(),o=z("a"),i=k(),s=z("div"),c.c(),T(n,"type","file"),T(n,"accept","application/json"),T(t,"class","helpers svelte-1juovjy")},m(c,d){y(c,t,d),g(t,n),e[19](n),g(t,r),g(t,o),e[20](o),y(c,i,d),y(c,s,d),p[a].m(s,null),l=!0,u||(f=S(n,"change",e[16]),u=!0)},p(e,[t]){let n=a;a=v(e),a===n?p[a].p(e,t):(J(),ee(p[n],1,1,(()=>{p[n]=null})),K(),c=p[a],c?c.p(e,t):(c=p[a]=d[a](e),c.c()),Q(c,1),c.m(s,null))},i(e){l||(Q(c),l=!0)},o(e){ee(c),l=!1},d(n){n&&b(t),e[19](null),e[20](null),n&&b(i),n&&b(s),p[a].d(),u=!1,f()}}}function Dt(e,t,n){let r,o,i,s,a,c;f(e,Te,(e=>n(2,r=e))),f(e,$e,(e=>n(5,s=e)));const{id:l,author:u,title:d,hasModified:p}=pe;f(e,l,(e=>n(7,c=e))),f(e,u,(e=>n(4,i=e))),f(e,d,(e=>n(3,o=e))),f(e,p,(e=>n(6,a=e)));const v=e=>{ye(e),x(Te,r={id:"scene"},r),location.hash&&_e("/")};let h,m;return[h,m,r,o,i,s,a,c,u,d,p,[{id:"scene",name:"Scene"},{id:"atlas",name:"Atlas"},{id:"effect",name:"Effect"},{id:"rendering",name:"Rendering"}],(e="")=>()=>_e("/gallery"+(e?`/${e}`:"")),e=>()=>v({scene:e}),e=>()=>{x(Te,r={id:e},r)},()=>h.click(),()=>{const e=h.files[0];if(!e)return;const t=new FileReader;t.addEventListener("load",(()=>{n(0,h.value=null,h),v(JSON.parse(t.result))}),!1),t.readAsText(e)},()=>{const e=new Blob([JSON.stringify({...be(),version:1})],{type:"application/json"});n(1,m.download="scene.json",m),n(1,m.href=URL.createObjectURL(e),m),m.click()},l,function(e){j[e?"unshift":"push"]((()=>{h=e,n(0,h)}))},function(e){j[e?"unshift":"push"]((()=>{m=e,n(1,m)}))}]}class Ot extends ae{constructor(e){super(),se(this,e,Dt,Vt,i,{})}}var Ft=1e-6,qt="undefined"!=typeof Float32Array?Float32Array:Array,Yt=Math.PI/180;function Xt(){var e=new qt(16);return qt!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function Wt(e,t,n,r){var o=t[0],i=t[1],s=t[2],a=t[3],c=o+o,l=i+i,u=s+s,f=o*c,d=o*l,p=o*u,v=i*l,h=i*u,m=s*u,x=a*c,g=a*l,y=a*u,b=r[0],w=r[1],z=r[2];return e[0]=(1-(v+m))*b,e[1]=(d+y)*b,e[2]=(p-g)*b,e[3]=0,e[4]=(d-y)*w,e[5]=(1-(f+m))*w,e[6]=(h+x)*w,e[7]=0,e[8]=(p+g)*z,e[9]=(h-x)*z,e[10]=(1-(f+v))*z,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var Zt=function(e,t,n,r,o){var i,s=1/Math.tan(t/2);return e[0]=s/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(i=1/(r-o),e[10]=(o+r)*i,e[14]=2*o*r*i):(e[10]=-1,e[14]=-2*r),e};function Ht(){var e=new qt(3);return qt!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Jt(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}var Kt=function(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e};function Qt(){var e=new qt(2);return qt!=Float32Array&&(e[0]=0,e[1]=0),e}function en(e,t){var n=new qt(2);return n[0]=e,n[1]=t,n}function tn(e,t,n){return e[0]=t,e[1]=n,e}Ht(),function(){var e=Qt()}();var nn="fn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn noise3(p: vec3<f32>) -> f32 {\n  let a = floor(p);\n  var d: vec3<f32> = p - a;\n  d = d * d * (3. - 2. * d);\n\n  let b = a.xxyy + vec4<f32>(0., 1., 0., 1.);\n  let k1 = permute4(b.xyxy);\n  let k2 = permute4(k1.xyxy + b.zzww);\n\n  let c = k2 + a.zzzz;\n  let k3 = permute4(c);\n  let k4 = permute4(c + 1.);\n\n  let o1 = fract(k3 * (1. / 41.));\n  let o2 = fract(k4 * (1. / 41.));\n\n  let o3 = o2 * d.z + o1 * (1. - d.z);\n  let o4 = o3.yw * d.x + o3.xz * (1. - d.x);\n\n  return o4.y * d.y + o4.x * (1. - d.y);\n}\n\nfn simplexNoise3(v: vec3<f32>) -> f32 {\n  let C = vec2<f32>(1. / 6., 1. / 3.);\n  let D = vec4<f32>(0., 0.5, 1., 2.);\n\n  var i: vec3<f32>  = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  let x1 = x0 - i1 + 1. * C.xxx;\n  let x2 = x0 - i2 + 2. * C.xxx;\n  let x3 = x0 - 1. + 3. * C.xxx;\n\n  i = i % vec3<f32>(289.);\n  let p = permute4(permute4(permute4(\n      i.z + vec4<f32>(0., i1.z, i2.z, 1. )) +\n      i.y + vec4<f32>(0., i1.y, i2.y, 1. )) +\n      i.x + vec4<f32>(0., i1.x, i2.x, 1. ));\n\n  var n_: f32 = 1. / 7.;\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49. * floor(p * ns.z * ns.z);\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_);\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = 1.0 - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  let s0 = floor(b0)*2.0 + 1.0;\n  let s1 = floor(b1)*2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  var p0: vec3<f32> = vec3<f32>(a0.xy, h.x);\n  var p1: vec3<f32> = vec3<f32>(a0.zw, h.y);\n  var p2: vec3<f32> = vec3<f32>(a1.xy, h.z);\n  var p3: vec3<f32> = vec3<f32>(a1.zw, h.w);\n\n  let norm = taylorInvSqrt4(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 = p0 * norm.x;\n  p1 = p1 * norm.y;\n  p2 = p2 * norm.z;\n  p3 = p3 * norm.w;\n\n  var m: vec4<f32> = 0.6 - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  m = max(m, vec4<f32>(0.));\n  m = m * m;\n  return 42. * dot(m * m, vec4<f32>(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n";class rn{constructor({device:e,count:t=254,width:n=16,height:r=16}){this.device=e,this.count=t,this.width=n,this.height=r,this.texture=e.createTexture({dimension:"2d",size:[n,r,t],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING})}compute(e="\nfn getColorAt(texture : i32, pixel : vec2<i32>) -> vec4<f32> {\n  var h : f32 = f32(texture) / f32(atlas.count);\n  var s : f32 = 0.5;\n  var l : f32 = 0.5;\n  if (pixel.x == 0 || pixel.y == 0 || pixel.x == (atlas.width - 1) || pixel.y == (atlas.height - 1)) {\n    l = min(l * 1.1, 1);\n  }\n  return hsl2Rgba(h, s, l);\n}\n"){if(this.generator===e)return;this.generator=e;const{device:t,count:n,width:r,height:o,texture:i}=this;this.code=(({count:e,width:t,height:n,generator:r})=>`\n@group(0) @binding(0) var texture : texture_storage_2d_array<rgba8unorm, write>;\n\n${nn}\n\nstruct Atlas {\n  count : i32,\n  width : i32,\n  height : i32,\n  stride : i32,\n  length : i32,\n}\n\nconst atlas : Atlas = Atlas(\n  ${e},\n  ${t},\n  ${n},\n  ${t*n},\n  ${e*t*n},\n);\n\nfn hue2Rgb(p : f32, q : f32, t : f32) -> f32 {\n  var h : f32 = t;\n  if (h < 0) { h += 1; }\n  if (h > 1) { h -= 1; }\n  if (h < 1 / 6.0) { return p + (q - p) * 6 * h; }\n  if (h < 1 / 2.0) { return q; }\n  if (h < 2 / 3.0) { return p + (q - p) * (2.0 / 3.0 - h) * 6; }\n  return p;\n}\n\nfn hsl2Rgba(h : f32, s: f32, l: f32) -> vec4<f32> {\n  var rgba : vec4<f32> = vec4<f32>(0, 0, 0, 1);\n  if (s == 0) {\n    rgba.r = l;\n    rgba.g = l;\n    rgba.b = l;\n  } else {\n    var q : f32;\n    if (l < 0.5) {\n      q = l * (1 + s);\n    } else {\n      q = l + s - l * s;\n    }\n    var p : f32 = 2 * l - q;\n    rgba.r = hue2Rgb(p, q, h + 1 / 3.0);\n    rgba.g = hue2Rgb(p, q, h);\n    rgba.b = hue2Rgb(p, q, h - 1 / 3.0);\n  }\n  return rgba;\n};\n\n${r}\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var id : i32 = i32(GlobalInvocationID.x);\n  if (id >= atlas.length) {\n    return;\n  }\n  var tex : i32 = id / atlas.stride;\n  var index : i32 = id - tex * atlas.stride;\n  var y : i32 = index / atlas.width;\n  var pixel : vec2<i32> = vec2<i32>(index - y * atlas.width, y);\n  textureStore(texture, pixel, tex, getColorAt(tex, pixel));\n}\n`)({count:n,width:r,height:o,generator:e}),this.shader=t.createShaderModule({code:this.code});const s=t.createComputePipeline({layout:"auto",compute:{module:this.shader,entryPoint:"main"}}),a=t.createCommandEncoder(),c=a.beginComputePass();c.setPipeline(s),c.setBindGroup(0,t.createBindGroup({layout:s.getBindGroupLayout(0),entries:[{binding:0,resource:i.createView()}]})),c.dispatchWorkgroups(Math.ceil(n*r*o/64)),c.end(),t.queue.submit([a.finish()])}}const on=Ht(),sn=function(e,t,n){var r=new qt(3);return r[0]=e,r[1]=t,r[2]=n,r}(0,1,0);class an{constructor({device:e,aspect:t=1,fov:n=75,near:r=.1,far:o=1e3}){this.device=e,this.buffer=e.createBuffer({size:39*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=t,this.fov=n,this.near=r,this.far=o,this.projectionMatrix=Xt(),this.viewBuffer=new Float32Array(22),this.viewMatrix=this.viewBuffer.subarray(0,16),this.position=this.viewBuffer.subarray(16,19),this.direction=this.viewBuffer.subarray(19,22),this.target=Ht()}setOrbit(e,t,n){const{position:r,target:o}=this,i=Math.sin(e)*n;(function(e,t,n){e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2]})(r,o,Jt(on,i*Math.sin(t),Math.cos(e)*n,i*Math.cos(t))),this.updateView()}updateProjection(){const{device:e,buffer:t,projectionMatrix:n,aspect:r,fov:o,near:i,far:s}=this;Zt(n,function(e){return e*Yt}(o),r,i,s),e.queue.writeBuffer(t,0,n)}updateView(){const{device:e,buffer:t,viewBuffer:n,direction:r,position:o,target:i,viewMatrix:s}=this;var a,c,l,u,f,d,p,v,h,m,x,g,y,b,w,z,$,k,S,T,E,C,M;a=s,l=i,u=sn,w=(c=o)[0],z=c[1],$=c[2],k=u[0],S=u[1],T=u[2],E=l[0],C=l[1],M=l[2],Math.abs(w-E)<Ft&&Math.abs(z-C)<Ft&&Math.abs($-M)<Ft?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(a):(x=w-E,g=z-C,y=$-M,f=S*(y*=b=1/Math.hypot(x,g,y))-T*(g*=b),d=T*(x*=b)-k*y,p=k*g-S*x,(b=Math.hypot(f,d,p))?(f*=b=1/b,d*=b,p*=b):(f=0,d=0,p=0),v=g*p-y*d,h=y*f-x*p,m=x*d-g*f,(b=Math.hypot(v,h,m))?(v*=b=1/b,h*=b,m*=b):(v=0,h=0,m=0),a[0]=f,a[1]=v,a[2]=x,a[3]=0,a[4]=d,a[5]=h,a[6]=g,a[7]=0,a[8]=p,a[9]=m,a[10]=y,a[11]=0,a[12]=-(f*w+d*z+p*$),a[13]=-(v*w+h*z+m*$),a[14]=-(x*w+g*z+y*$),a[15]=1),function(e,t){var n=t[0],r=t[1],o=t[2],i=n*n+r*r+o*o;i>0&&(i=1/Math.sqrt(i)),e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i}(r,Kt(r,i,o)),e.queue.writeBuffer(t,64,n)}}var cn="const PI : f32 = 3.141592653589793;\n\nfn rotateX(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    1, 0, 0,\n    0, c, s,\n    0, -s, c,\n  );\n}\n\nfn rotateY(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c,\n  );\n}\n\nfn rotateZ(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, s, 0,\n    -s, c, 0,\n    0, 0, 1,\n  );\n}\n";const ln=({source:e})=>`\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n  position : vec3<f32>,\n  direction : vec3<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<uniform> size : vec2<i32>;\n@group(0) @binding(2) var<uniform> time : f32;\n@group(0) @binding(3) var colorTexture : texture_2d<f32>;\n@group(0) @binding(4) var normalTexture : texture_2d<f32>;\n@group(0) @binding(5) var positionTexture : texture_2d<f32>;\n\n${e}\n\n@fragment\nfn main(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  return getColor(vec2<i32>(floor(uv.xy)), size, camera, time);\n}\n`;class un{constructor({device:e}){this.device=e,this.data=new Int32Array(2),this.buffer=e.createBuffer({size:this.data.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM})}destroy(){const{buffer:e}=this;e.destroy()}set(e){const{device:t,buffer:n,data:r}=this;r.set(e),t.queue.writeBuffer(n,0,r)}}class fn{constructor({device:e,camera:t,format:n,time:r}){this.device=e,this.camera=t,this.format=n,this.time=r,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},this.geometry=(e=>{const t=e.createBuffer({size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(t.getMappedRange()).set([-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1]),t.unmap(),t})(e),this.size=new un({device:e})}bindTextures({color:e,normal:t,position:n}){const{device:r,camera:o,pipeline:i,size:s,time:a}=this;this.textures={color:e,normal:t,position:n},i&&(this.bindings=r.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:o.buffer}},{binding:1,resource:{buffer:s.buffer}},{binding:2,resource:{buffer:a.buffer}},{binding:3,resource:e},{binding:4,resource:t},{binding:5,resource:n}]}))}destroy(){const{geometry:e,size:t}=this;e.destroy(),t.destroy()}setEffect(e="\nstruct Effect {\n  color : vec3<f32>,\n  intensity : f32,\n  depthScale : f32,\n  normalScale : f32,\n}\n\nconst effect : Effect = Effect(\n  vec3<f32>(0, 0, 0),\n  0.3,\n  0.5,\n  0.5,\n);\n\nconst offset : vec3<i32> = vec3<i32>(1, 1, 0);\n\nfn edgesDepth(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : f32 = textureLoad(positionTexture, pixel, 0).w;\n  var pixelLeft : f32 = textureLoad(positionTexture, pixel - offset.xz, 0).w;\n  var pixelRight : f32 = textureLoad(positionTexture, pixel + offset.xz, 0).w;\n  var pixelUp : f32 = textureLoad(positionTexture, pixel + offset.zy, 0).w;\n  var pixelDown : f32 = textureLoad(positionTexture, pixel - offset.zy, 0).w;\n  return (\n    abs(pixelLeft    - pixelCenter) \n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter) \n  ) * effect.depthScale;\n}\n\nfn edgesNormal(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : vec3<f32> = textureLoad(normalTexture, pixel, 0).xyz;\n  var pixelLeft : vec3<f32> = textureLoad(normalTexture, pixel - offset.xz, 0).xyz;\n  var pixelRight : vec3<f32> = textureLoad(normalTexture, pixel + offset.xz, 0).xyz;\n  var pixelUp : vec3<f32> = textureLoad(normalTexture, pixel + offset.zy, 0).xyz;\n  var pixelDown : vec3<f32> = textureLoad(normalTexture, pixel - offset.zy, 0).xyz;\n  var edge : vec3<f32> = (\n    abs(pixelLeft    - pixelCenter)\n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter)\n  );\n  return (edge.x + edge.y + edge.z) * effect.normalScale;\n}\n\nfn getColor(pixel : vec2<i32>, size : vec2<i32>, camera : Camera, time : f32) -> vec4<f32> {\n  var color : vec3<f32> = textureLoad(colorTexture, pixel, 0).xyz;\n  color = mix(color, effect.color, clamp(max(edgesDepth(pixel), edgesNormal(pixel)), 0, 1) * effect.intensity);\n  return vec4<f32>(color, 1);\n}\n"){const{device:t,format:n,textures:r}=this;this.code=ln({source:e}),this.shader=t.createShaderModule({code:ln({source:e})}),this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{module:t.createShaderModule({code:"\n@vertex\nfn main(@location(0) position : vec4<f32>) -> @builtin(position) vec4<f32> {\n  return position;\n}\n"}),entryPoint:"main",buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]}]},fragment:{module:this.shader,entryPoint:"main",targets:[{format:n}]},primitive:{topology:"triangle-list"}}),r&&this.bindTextures(r)}render(e,t){const{bindings:n,descriptor:r,geometry:o,pipeline:i}=this;r.colorAttachments[0].view=t;const s=e.beginRenderPass(r);s.setPipeline(i),s.setBindGroup(0,n),s.setVertexBuffer(0,o),s.draw(6,1,0,0),s.end()}}const dn=`\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) face : vec4<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) worldPosition : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>,\n  @location(3) depth : f32,\n  @location(4) @interpolate(flat) texture : i32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n${cn}\n\nconst faceNormal : vec3<f32> = vec3<f32>(0, 0, 1);\n\n@vertex\nfn main(voxel : VertexInput) -> VertexOutput {\n  var rotation : mat3x3<f32>;\n  switch (i32(voxel.face.w % 6)) {\n    default {\n      rotation = mat3x3<f32>(\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1,\n      );\n    }\n    case 1 {\n      rotation = rotateX(PI * -0.5);\n    }\n    case 2 {\n      rotation = rotateX(PI * 0.5);\n    }\n    case 3 {\n      rotation = rotateY(PI * -0.5);\n    }\n    case 4 {\n      rotation = rotateY(PI * 0.5);\n    }\n    case 5 {\n      rotation = rotateY(PI);\n    }\n  }\n  var position : vec4<f32> = vec4<f32>(rotation * voxel.position + voxel.face.xyz, 1);\n  var mvPosition : vec4<f32> = camera.view * position;\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.worldPosition = position.xyz;\n  out.normal = normalize(rotation * faceNormal);\n  out.uv = voxel.uv;\n  out.depth = -mvPosition.z;\n  out.texture = i32(floor(voxel.face.w / 6));\n  return out;\n}\n`,pn=e=>{const t=e.createBuffer({size:30*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(t.getMappedRange()).set([-.5,-.5,.5,0,1,.5,-.5,.5,1,1,.5,.5,.5,1,0,.5,.5,.5,1,0,-.5,.5,.5,0,0,-.5,-.5,.5,0,1]),t.unmap(),t};class vn{constructor({device:e}){this.device=e,this.data=new Float32Array(1),this.buffer=e.createBuffer({size:this.data.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM})}destroy(){const{buffer:e}=this;e.destroy()}set(e){const{device:t,buffer:n,data:r}=this;r[0]=e,t.queue.writeBuffer(n,0,r)}}class hn{constructor({adapter:e,device:t,atlas:n=null,camera:r=null,canvas:o=null,samples:i=4}){const s=navigator.gpu.getPreferredCanvasFormat(e);this.atlas=n||new rn({device:t}),this.camera=r||new an({device:t}),this.canvas=o||document.createElement("canvas"),this.canvas.width=Math.floor(window.innerWidth*(window.devicePixelRatio||1)),this.canvas.height=Math.floor(window.innerHeight*(window.devicePixelRatio||1)),this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:t,format:s}),this.device=t,this.samples=i,this.time=new vn({device:t});const a=t.createRenderPipeline({layout:"auto",vertex:{module:t.createShaderModule({code:dn}),entryPoint:"main",buffers:[{arrayStride:5*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]},{arrayStride:4*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x4"}]}]},fragment:{module:t.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>,\n  @location(3) depth : f32,\n  @location(4) @interpolate(flat) texture : i32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) normal : vec4<f32>,\n  @location(2) position : vec4<f32>,\n}\n\n@group(0) @binding(1) var atlas : texture_2d_array<f32>;\n@group(0) @binding(2) var atlasSampler : sampler;\n\n@fragment\nfn main(face : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = textureSample(atlas, atlasSampler, face.uv, face.texture);\n  output.normal = vec4<f32>(normalize(face.normal), 1);\n  output.position = vec4<f32>(face.position, face.depth);\n  return output;\n}\n"}),entryPoint:"main",targets:[{format:"rgba8unorm"},{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:this.samples}});this.rendering={bindings:t.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.camera.buffer}},{binding:1,resource:this.atlas.texture.createView()},{binding:2,resource:t.createSampler()}]}),descriptor:{colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},geometry:pn(t),pipeline:a},this.postprocessing=new fn({device:t,camera:this.camera,format:s,time:this.time})}render(e,t){const{context:n,postprocessing:r,rendering:{bindings:o,descriptor:i,geometry:s,pipeline:a}}=this,c=e.beginRenderPass(i);c.setPipeline(a),c.setBindGroup(0,o),c.setVertexBuffer(0,s),t.chunks.forEach((({faces:e})=>{c.setVertexBuffer(1,e,16),c.drawIndirect(e,0)})),c.end(),r.render(e,n.getCurrentTexture().createView())}setClearColor(e,t,n){const{rendering:{descriptor:{colorAttachments:[{clearValue:r}]}}}=this;r.r=e,r.g=t,r.b=n}setSize(e,t){const{camera:n,canvas:r,device:o,postprocessing:i,rendering:s,samples:a}=this,c=window.devicePixelRatio||1,l=[Math.floor(e*c),Math.floor(t*c)];r.width=l[0],r.height=l[1],r.style.width=`${e}px`,r.style.height=`${t}px`,n.aspect=e/t,n.updateProjection();const u=(e,t,n,r)=>(e[t]&&e[t].destroy(),e[t]=o.createTexture({size:l,sampleCount:n,format:r,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),e[t].createView());s.descriptor.colorAttachments[0].view=u(s,"colorTexture",a,"rgba8unorm"),s.descriptor.colorAttachments[0].resolveTarget=u(s,"colorTarget",1,"rgba8unorm"),s.descriptor.colorAttachments[1].view=u(s,"normalTexture",a,"rgba16float"),s.descriptor.colorAttachments[1].resolveTarget=u(s,"normalTarget",1,"rgba16float"),s.descriptor.colorAttachments[2].view=u(s,"positionTexture",a,"rgba16float"),s.descriptor.colorAttachments[2].resolveTarget=u(s,"positionTarget",1,"rgba16float"),s.descriptor.depthStencilAttachment.view=u(s,"depthTexture",a,"depth24plus"),i.bindTextures({color:s.colorTarget.createView(),normal:s.normalTarget.createView(),position:s.positionTarget.createView()}),i.size.set(l)}}var mn=({chunkSize:e})=>`\nconst chunkSize : i32 = ${e};\n\nfn getVoxel(pos : vec3<i32>) -> u32 {\n  return u32(pos.z * chunkSize * chunkSize + pos.y * chunkSize + pos.x);\n}\n`;const xn=({chunkSize:e})=>`\nstruct Faces {\n  vertexCount : u32,\n  instanceCount : atomic<u32>,\n  firstVertex : u32,\n  firstInstance : u32,\n  data : array<f32>,\n}\n\n@group(0) @binding(0) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(1) var<storage, read_write> faces : Faces;\n@group(0) @binding(2) var<storage, read> voxels : array<f32>;\n@group(0) @binding(3) var<storage, read> voxels_north : array<f32>;\n@group(0) @binding(4) var<storage, read> voxels_top : array<f32>;\n@group(0) @binding(5) var<storage, read> voxels_bottom : array<f32>;\n@group(0) @binding(6) var<storage, read> voxels_west : array<f32>;\n@group(0) @binding(7) var<storage, read> voxels_east : array<f32>;\n@group(0) @binding(8) var<storage, read> voxels_south : array<f32>;\n\n${mn({chunkSize:e})}\n\nfn isAir(pos : vec3<i32>) -> bool {\n  if (pos.x == -1) {\n    return voxels_west[getVoxel(vec3<i32>(chunkSize - 1, pos.y, pos.z))] == 0;\n  }\n  if (pos.x == chunkSize) {\n    return voxels_east[getVoxel(vec3<i32>(0, pos.y, pos.z))] == 0.0;\n  }\n  if (pos.y == -1) {\n    return voxels_bottom[getVoxel(vec3<i32>(pos.x, chunkSize - 1, pos.z))] == 0;\n  }\n  if (pos.y == chunkSize) {\n    return voxels_top[getVoxel(vec3<i32>(pos.x, 0, pos.z))] == 0;\n  }\n  if (pos.z == -1) {\n    return voxels_south[getVoxel(vec3<i32>(pos.x, pos.y, chunkSize - 1))] == 0;\n  }\n  if (pos.z == chunkSize) {\n    return voxels_north[getVoxel(vec3<i32>(pos.x, pos.y, 0))] == 0;\n  }\n  return voxels[getVoxel(pos)] == 0; \n}\n\nfn pushFace(pos : vec3<i32>, face : i32, texture : i32) {\n  var offset : u32 = atomicAdd(&(faces.instanceCount), 1) * 4;\n  faces.data[offset] = f32(pos.x) + 0.5;\n  faces.data[offset + 1] = f32(pos.y) + 0.5;\n  faces.data[offset + 2] = f32(pos.z) + 0.5;\n  faces.data[offset + 3] = f32(texture * 6 + face);\n}\n\nconst faceNormals = array<vec3<i32>, 6>(\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 1, 0),\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(0, 0, -1),\n);\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize || pos.y >= chunkSize || pos.z >= chunkSize\n  ) {\n    return;\n  }\n  var value : f32 = voxels[getVoxel(pos)];\n  if (value != 0) {\n    var texture : i32 = i32(floor(value) - 1);\n    for (var face : i32 = 0; face < 6; face++) {\n      var npos : vec3<i32> = pos + faceNormals[face];\n      if (isAir(npos)) {\n        pushFace(chunk + pos, face, texture);\n      }\n    }\n  }\n}\n`;class gn{constructor({chunks:e,volume:t}){this.pipeline=t.device.createComputePipeline({layout:"auto",compute:{module:t.device.createShaderModule({code:xn({chunkSize:t.chunkSize})}),entryPoint:"main"}});const n={x:0,y:0,z:0},r=(r,o)=>{if(n.x=r.x+o.x,n.y=r.y+o.y,n.z=r.z+o.z,n.x<0||n.x>=e.x||n.y<0||n.y>=e.y||n.z<0||n.z>=e.z)return t.edge;const i=n.z*e.x*e.y+n.y*e.x+n.x;return t.chunks[i].voxels},o=[{x:0,y:0,z:1},{x:0,y:1,z:0},{x:0,y:-1,z:0},{x:-1,y:0,z:0},{x:1,y:0,z:0},{x:0,y:0,z:-1}];this.bindings=t.chunks.map((e=>({bindings:t.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[e.position,e.faces,e.voxels,...o.map((t=>r(e.chunk,t)))].map(((e,t)=>({binding:t,resource:{buffer:e}})))}),chunk:e}))),this.workgroups=Math.ceil(t.chunkSize/4)}compute(e){const{bindings:t,pipeline:n,workgroups:r}=this;t.forEach((({bindings:t,chunk:o})=>{o.resetInstanceCount(e);const i=e.beginComputePass();i.setPipeline(n),i.setBindGroup(0,t),i.dispatchWorkgroups(r,r,r),i.end()}))}}class yn{constructor({device:e,position:t=new Float32Array([0,0,0]),rotation:n=new Float32Array([0,0,0,1]),scale:r=new Float32Array([1,1,1])}){this.device=e,this.data=Xt(),this.buffer=e.createBuffer({mappedAtCreation:!0,size:this.data.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),Wt(this.data,n,t,r),new Float32Array(this.buffer.getMappedRange()).set(this.data),this.buffer.unmap()}destroy(){const{buffer:e}=this;e.destroy()}set(e,t,n){const{device:r,buffer:o,data:i}=this;Wt(i,t,e,n),r.queue.writeBuffer(o,0,i)}}class bn{constructor({geometry:e,volume:t}){const n=e.indices.length/3;this.code=(({chunkSize:e,source:t,triangles:n})=>`\n@group(0) @binding(0) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(1) var<uniform> transform : mat4x4<f32>;\n@group(0) @binding(2) var<storage, read> indices : array<array<u32, 3>>;\n@group(0) @binding(3) var<storage, read> vertices : array<array<f32, 3>>;\n@group(0) @binding(4) var<storage, read_write> voxels : array<f32>;\n\n${mn({chunkSize:e})}\n\nstruct AxisTest {\n  ann : vec3<f32>,\n  fnn : vec3<f32>,\n  aa : i32,\n  bb : i32,\n}\n\nfn intersects(triangle : array<vec3<f32>, 3>, voxel : vec3<f32>) -> bool {\n  var v0 : vec3<f32> = triangle[0] - voxel;\n  var v1 : vec3<f32> = triangle[1] - voxel;\n  var v2 : vec3<f32> = triangle[2] - voxel;\n\n  var f0 : vec3<f32> = v1 - v0;\n  var f1 : vec3<f32> = v2 - v1;\n  var f2 : vec3<f32> = v0 - v2;\n\n  var axis_test = array<AxisTest, 9>(\n    AxisTest(vec3<f32>(0, -f0.z, f0.y), f0, 1, 2),\n    AxisTest(vec3<f32>(0, -f1.z, f1.y), f1, 1, 2),\n    AxisTest(vec3<f32>(0, -f2.z, f2.y), f2, 1, 2),\n    AxisTest(vec3<f32>(f0.z, 0, -f0.x), f0, 0, 2),\n    AxisTest(vec3<f32>(f1.z, 0, -f1.x), f1, 0, 2),\n    AxisTest(vec3<f32>(f2.z, 0, -f2.x), f2, 0, 2),\n    AxisTest(vec3<f32>(-f0.y, f0.x, 0), f0, 0, 1),\n    AxisTest(vec3<f32>(-f1.y, f1.x, 0), f1, 0, 1),\n    AxisTest(vec3<f32>(-f2.y, f2.x, 0), f2, 0, 1),\n  );\n\n  for (var i : i32 = 0; i < 9; i++) {\n    var t : AxisTest = axis_test[i];\n    var p0 : f32 = dot(v0, t.ann);\n    var p1 : f32 = dot(v1, t.ann);\n    var p2 : f32 = dot(v2, t.ann);\n    var r : f32 = 0.5 * abs(t.fnn[t.bb]) + 0.5 * abs(t.fnn[t.aa]);\n    if (max(-max(p0, max(p1, p2)), min(p0, min(p1, p2))) > r) {\n      return false;\n    }\n  }\n\n  if (max(v0.x, max(v1.x, v2.x)) < -0.5 || min(v0.x, min(v1.x, v2.x)) > 0.5) {\n    return false;\n  }\n  if (max(v0.y, max(v1.y, v2.y)) < -0.5 || min(v0.y, min(v1.y, v2.y)) > 0.5) {\n    return false;\n  }\n  if (max(v0.z, max(v1.z, v2.z)) < -0.5 || min(v0.z, min(v1.z, v2.z)) > 0.5) {\n    return false;\n  }\n\n  var planeNorm : vec3<f32> = normalize(cross(f1, f0));\n  var planeConst : f32 = dot(planeNorm, triangle[0]);\n  var r : f32 = 0.5 * abs(planeNorm.x) + 0.5 * abs(planeNorm.y) + 0.5 * abs(planeNorm.z);\n  var s : f32 = abs(dot(planeNorm, voxel) - planeConst);\n  return s <= r;\n}\n\nfn getVertex(index : u32) -> vec3<f32> {\n  var vertex : vec4<f32> = vec4<f32>(vertices[index][0], vertices[index][1], vertices[index][2], 1);\n  return (transform * vertex).xyz - vec3<f32>(chunk);\n}\n\nconst triangles : u32 = ${n};\n\n${t}\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var id : u32 = GlobalInvocationID.x;\n  if (id >= triangles) {\n    return;\n  }\n\n  var triangle = array<vec3<f32>, 3>(\n    getVertex(indices[id][0]),\n    getVertex(indices[id][1]),\n    getVertex(indices[id][2]),\n  );\n\n  var tmin : vec3<i32> = vec3<i32>(chunkSize);\n  var tmax : vec3<i32> = vec3<i32>(0);\n  for (var i : i32 = 0; i < 3; i++) {\n    var p = vec3<i32>(triangle[i]);\n    tmin = min(tmin, p);\n    tmax = max(tmax, p);\n  }\n  tmin = clamp(tmin, vec3<i32>(0), vec3<i32>(chunkSize - 1));\n  tmax = clamp(tmax, vec3<i32>(0), vec3<i32>(chunkSize - 1));\n\n  for (var z : i32 = tmin.z; z <= tmax.z; z++) {\n    for (var y : i32 = tmin.y; y <= tmax.y; y++) {\n      for (var x : i32 = tmin.x; x <= tmax.x; x++) {\n        if (intersects(triangle, vec3<f32>(f32(x) + 0.5, f32(y) + 0.5, f32(z) + 0.5))) {\n          var pos : vec3<i32> = vec3<i32>(x, y, z);\n          voxels[getVoxel(pos)] = getValueAt(vec3<f32>(chunk + pos));\n        }\n      }\n    }\n  }\n}\n`)({chunkSize:t.chunkSize,source:e.source||"\nfn getValueAt(pos : vec3<f32>) -> f32 {\n  return 1;\n}\n",triangles:n}),this.shader=t.device.createShaderModule({code:this.code}),this.pipeline=t.device.createComputePipeline({layout:"auto",compute:{module:this.shader,entryPoint:"main"}}),this.transform=new yn({device:t.device,position:e.position,rotation:e.rotation,scale:e.scale}),this.indices=t.device.createBuffer({mappedAtCreation:!0,size:e.indices.byteLength,usage:GPUBufferUsage.STORAGE}),new Uint32Array(this.indices.getMappedRange()).set(e.indices),this.indices.unmap(),this.vertices=t.device.createBuffer({mappedAtCreation:!0,size:e.vertices.byteLength,usage:GPUBufferUsage.STORAGE}),new Float32Array(this.vertices.getMappedRange()).set(e.vertices),this.vertices.unmap(),this.bindings=t.chunks.map((({position:e,voxels:n})=>({bindings:t.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[e,this.transform.buffer,this.indices,this.vertices,n].map(((e,t)=>({binding:t,resource:{buffer:e}})))}),clearChunk:e=>e.clearBuffer(n)}))),this.workgroups=Math.ceil(n/64)}compute(e){const{bindings:t,pipeline:n,workgroups:r}=this;t.forEach((({bindings:t,clearChunk:o})=>{o(e);const i=e.beginComputePass();i.setPipeline(n),i.setBindGroup(0,t),i.dispatchWorkgroups(r),i.end()}))}destroy(){const{transform:e,indices:t,vertices:n}=this;e.destroy(),t.destroy(),n.destroy()}}class wn{constructor({source:e,volume:t}){this.code=(({chunkSize:e,width:t,height:n,depth:r,source:o})=>`\n@group(0) @binding(0) var<uniform> time : f32;\n@group(0) @binding(1) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(2) var<storage, read_write> voxels : array<f32>;\n\n${nn}\n${cn}\nfn sdBox(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var q : vec3<f32> = abs(p) - r;\n  return length(max(q, vec3<f32>(0))) + min(max(q.x, max(q.y, q.z)), 0);\n}\n\nfn sdCapsule(p : vec3<f32>, r : vec2<f32>) -> f32 {\n  var q : vec3<f32> = vec3<f32>(p.x, p.y - clamp(p.y, -r.y + r.x, r.y - r.x), p.z);\n  return length(q) - r.x;\n}\n\nfn sdEllipsoid(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var k0 : f32 = length(p / r);\n  var k1 : f32 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\n\nfn sdSphere(p : vec3<f32>, r : f32) -> f32 {\n  return length(p) - r;\n}\n\nfn sdTorus(p : vec3<f32>, r : vec2<f32>) -> f32 {\n  var q : vec2<f32> = vec2<f32>(length(p.xz) - r.x, p.y);\n  return length(q) - r.y;\n}\n\nfn opUnion(d1 : f32, d2 : f32) -> f32 {\n  return min(d1, d2);\n}\n\nfn opSubstraction(d1 : f32, d2 : f32) -> f32 {\n  return max(d1, -d2);\n}\n\nfn opSmoothUnion(d1 : f32, d2 : f32, k : f32) -> f32 {\n  var h : f32 = clamp(0.5 + 0.5 * (d2 - d1) / k, 0, 1);\n  return mix(d2, d1, h) + k * h * (1 - h);\n}\n\nfn opSmoothSubstraction(d1 : f32, d2 : f32, k : f32) -> f32 {\n  var h : f32 = clamp(0.5 - 0.5 * (d2 + d1) / k, 0, 1);\n  return mix(d1, -d2, h) + k * h * (1 - h);\n}\n\n${mn({chunkSize:e})}\n\nstruct Volume {\n  center : vec3<f32>,\n  size : vec3<f32>,\n}\n\nconst volume : Volume = Volume(\n  vec3<f32>(${.5*t}, ${.5*n}, ${.5*r}),\n  vec3<f32>(${t}, ${n}, ${r})\n);\n\n${o}\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize || pos.y >= chunkSize || pos.z >= chunkSize\n  ) {\n    return;\n  }\n  voxels[getVoxel(pos)] = getValueAt(vec3<f32>(chunk + pos), time);\n}\n`)({chunkSize:t.chunkSize,width:t.width,height:t.height,depth:t.depth,source:e}),this.shader=t.device.createShaderModule({code:this.code}),this.pipeline=t.device.createComputePipeline({layout:"auto",compute:{module:this.shader,entryPoint:"main"}}),this.bindings=t.chunks.map((({position:e,voxels:n})=>t.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[t.time.buffer,e,n].map(((e,t)=>({binding:t,resource:{buffer:e}})))}))),this.workgroups=Math.ceil(t.chunkSize/4)}compute(e){const{bindings:t,pipeline:n,workgroups:r}=this;t.forEach((t=>{const o=e.beginComputePass();o.setPipeline(n),o.setBindGroup(0,t),o.dispatchWorkgroups(r,r,r),o.end()}))}}class zn{constructor({device:e,chunk:t,chunkSize:n}){this.chunk=t,this.faces=e.createBuffer({mappedAtCreation:!0,size:4*Uint32Array.BYTES_PER_ELEMENT+6*Math.ceil(n*n*n*.5)*4*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),new Uint32Array(this.faces.getMappedRange())[0]=6,this.faces.unmap(),this.position=e.createBuffer({mappedAtCreation:!0,size:3*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM}),new Int32Array(this.position.getMappedRange()).set([t.x*n,t.y*n,t.z*n]),this.position.unmap(),this.voxels=zn.createVoxelsBuffer({device:e,chunkSize:n})}destroy(){const{faces:e,position:t,voxels:n}=this;e.destroy(),t.destroy(),n.destroy()}resetInstanceCount(e){const{faces:t}=this;e.clearBuffer(t,4,4)}static createVoxelsBuffer({device:e,chunkSize:t}){return e.createBuffer({size:t*t*t*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE})}}class $n{constructor({chunkSize:e=100,device:t,time:n,width:r,height:o,depth:i}){this.chunkSize=e,this.device=t,this.time=n,this.width=r,this.height=o,this.depth=i;const s={x:Math.ceil(r/e),y:Math.ceil(o/e),z:Math.ceil(i/e)};this.chunks=[];for(let n=0;n<s.z;n++)for(let r=0;r<s.y;r++)for(let o=0;o<s.x;o++)this.chunks.push(new zn({device:t,chunk:{x:o,y:r,z:n},chunkSize:e}));this.edge=zn.createVoxelsBuffer({device:t,chunkSize:e}),this.mesher=new gn({chunks:s,volume:this})}compute(e){const{mesher:t,voxelizer:n}=this;n.compute(e),t.compute(e)}destroy(){const{chunks:e,edge:t,voxelizer:n}=this;e.forEach((e=>e.destroy())),t.destroy(),n&&n.destroy&&n.destroy()}setScene(e){const{voxelizer:t}=this;t&&t.destroy&&t.destroy(),e.geometry?this.voxelizer=new bn({geometry:e.geometry,volume:this}):e.source&&(this.voxelizer=new wn({source:e.source,volume:this}))}}class kn{constructor(e){this.look={state:en(.5*Math.PI,0),target:en(.5*Math.PI,0)},this.pointer={movement:Qt(),position:Qt()},this.zoom={state:.75,target:.75},this.target=e,this.updateBounds(),this.onMouseDown=this.onMouseDown.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onMouseWheel=this.onMouseWheel.bind(this),e.addEventListener("mousedown",this.onMouseDown,!1),window.addEventListener("mousemove",this.onMouseMove,!1),window.addEventListener("mouseup",this.onMouseUp,!1),window.addEventListener("wheel",this.onMouseWheel,{passive:!1})}destroy(){this.target.removeEventListener("mousedown",this.onMouseDown),window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("mouseup",this.onMouseUp),window.removeEventListener("wheel",this.onMouseWheel)}onMouseDown({button:e}){const{pointer:t}=this;t.isDown=0===e}onMouseMove({clientX:e,clientY:t,movementX:n,movementY:r}){const{sensitivity:o}=kn,{bounds:i,pointer:{movement:s,position:a}}=this;s[0]-=n*o.look,s[1]-=r*o.look,tn(a,(e-i.x)/i.width*2-1,-(t-i.y)/i.height*2+1)}onMouseUp({button:e}){const{pointer:t}=this;0===e&&(t.isDown=!1)}onMouseWheel(e){e.ctrlKey&&e.preventDefault();const{sensitivity:t,minZoom:n,zoomRange:r}=kn,{zoom:o}=this,i=Math.min(Math.max((Math.log(o.target)-n)/r+e.deltaY*t.zoom,0),1);o.target=Math.exp(n+i*r)}update(e){const{minPhi:t,maxPhi:n}=kn,{pointer:r,look:o,zoom:i}=this;r.isDown&&(o.target[1]+=r.movement[0],o.target[0]=Math.min(Math.max(o.target[0]+r.movement[1],t),n));const s=1-Math.exp(-10*e);!function(e,t,n,r){var o=t[0],i=t[1];e[0]=o+r*(n[0]-o),e[1]=i+r*(n[1]-i)}(o.state,o.state,o.target,s),i.state=i.state*(1-s)+i.target*s,tn(r.movement,0,0)}updateBounds(){const{target:e}=this;this.bounds=e.getBoundingClientRect()}}function Sn(t){let n;return{c(){n=z("div"),T(n,"class","viewport svelte-vo8in0")},m(e,r){y(e,n,r),t[1](n)},p:e,i:e,o:e,d(e){e&&b(n),t[1](null)}}}function Tn(e,t,n){let r;return B((()=>{const e=new kn(r),t=new hn(ge.gpu);r.appendChild(t.canvas),t.setSize(window.innerWidth,window.innerHeight),t.setSize(e.bounds.width,e.bounds.height),window.addEventListener("resize",(()=>{e.updateBounds(),t.setSize(e.bounds.width,e.bounds.height)}),!1);let n,o=performance.now()/1e3,i=!1;const s=()=>{requestAnimationFrame(s);const r=performance.now()/1e3,a=r-o;if(o=r,e.update(a),t.camera.setOrbit(e.look.state[0],e.look.state[1],n.width*e.zoom.state),i)return;t.time.set(r);const c=t.device.createCommandEncoder();n.compute(c),t.render(c,n),t.device.queue.submit([c.finish()])};requestAnimationFrame(s);const a=({code:e,shader:t},n)=>{i=!1;const r=e.split("\n"),o=r.indexOf("// __SOURCE__")+1;t.compilationInfo().then((({messages:e})=>n.set(e.map((({length:e,lineNum:t,linePos:n,message:s,type:a})=>(i=!0,{line:r[t-1],lineNum:t-o,linePos:n,length:e,message:s,pointer:Array.from({length:n-1+e},((e,t)=>t>=n-1?"^":" ")).join(""),type:a}))))))},c=[ge.background.subscribe((e=>{return t.setClearColor(...(n=e,[parseInt(n.slice(1,3),16)/255,parseInt(n.slice(3,5),16)/255,parseInt(n.slice(5,7),16)/255]));var n})),ge.resolution.subscribe((e=>{let r;n&&(r=n.source,n.destroy()),n=new $n({device:t.device,time:t.time,width:e,height:e,depth:e}),r&&(n.source=r,n.setScene({source:r})),Jt(t.camera.target,.5*n.width,.5*n.height,.5*n.depth)})),me.source.subscribe((e=>{e="// __SOURCE__\n"+e,t.atlas.compute(e),a(t.atlas,me.errors)})),xe.source.subscribe((e=>{e="// __SOURCE__\n"+e,t.postprocessing.setEffect(e),a(t.postprocessing,xe.errors)})),he.source.subscribe((e=>{n.source=e,e="// __SOURCE__\n"+e,n.setScene({source:e}),a(n.voxelizer,he.errors)}))];return ge.screenshot=((e,t=512)=>()=>{const n=document.createElement("canvas"),r=n.getContext("2d");n.width=t,n.height=t;let o=0,i=0,s=e.canvas.width,a=e.canvas.height;return s>a?(o=-.5*(a-s),s=a):(i=-.5*(s-a),a=s),r.drawImage(e.canvas,o,i,a,s,0,0,t,t),n.toDataURL()})(t),()=>{c.forEach((e=>e())),e.destroy(),n.destroy(),delete ge.screenshot}})),[r,function(e){j[e?"unshift":"push"]((()=>{r=e,n(0,r)}))}]}kn.sensitivity={look:.003,zoom:3e-4},kn.minPhi=1e-6,kn.maxPhi=Math.PI-1e-6,kn.minZoom=Math.log(.25),kn.maxZoom=Math.log(1.5),kn.zoomRange=kn.maxZoom-kn.minZoom;class En extends ae{constructor(e){super(),se(this,e,Tn,Sn,i,{})}}const{window:Cn}=te;function Mn(e){let t,n;return t=new xt({}),{c(){re(t.$$.fragment)},m(e,r){oe(t,e,r),n=!0},i(e){n||(Q(t.$$.fragment,e),n=!0)},o(e){ee(t.$$.fragment,e),n=!1},d(e){ie(t,e)}}}function _n(e){let t,n;return t=new ht({}),{c(){re(t.$$.fragment)},m(e,r){oe(t,e,r),n=!0},i(e){n||(Q(t.$$.fragment,e),n=!0)},o(e){ee(t.$$.fragment,e),n=!1},d(e){ie(t,e)}}}function Pn(e){let t,n;return t=new ut({}),{c(){re(t.$$.fragment)},m(e,r){oe(t,e,r),n=!0},i(e){n||(Q(t.$$.fragment,e),n=!0)},o(e){ee(t.$$.fragment,e),n=!1},d(e){ie(t,e)}}}function An(e){let t,n;return t=new He({}),{c(){re(t.$$.fragment)},m(e,r){oe(t,e,r),n=!0},i(e){n||(Q(t.$$.fragment,e),n=!0)},o(e){ee(t.$$.fragment,e),n=!1},d(e){ie(t,e)}}}function Bn(e){let t,n;return t=new Ie({}),{c(){re(t.$$.fragment)},m(e,r){oe(t,e,r),n=!0},i(e){n||(Q(t.$$.fragment,e),n=!0)},o(e){ee(t.$$.fragment,e),n=!1},d(e){ie(t,e)}}}function Un(e){let t,n;return t=new je({}),{c(){re(t.$$.fragment)},m(e,r){oe(t,e,r),n=!0},i(e){n||(Q(t.$$.fragment,e),n=!0)},o(e){ee(t.$$.fragment,e),n=!1},d(e){ie(t,e)}}}function Ln(e){let t,n,o,i,s,a,c,l,u,f,d,p,v;o=new Ot({});const h=[Un,Bn,An,Pn,_n,Mn],m=[];function x(e,t){return"atlas"===e[1].id?0:"effect"===e[1].id?1:"gallery"===e[1].id?2:"publish"===e[1].id?3:"rendering"===e[1].id?4:"scene"===e[1].id?5:-1}return~(s=x(e))&&(a=m[s]=h[s](e)),f=new En({}),{c(){t=z("div"),n=z("div"),re(o.$$.fragment),i=k(),a&&a.c(),c=k(),l=z("div"),u=k(),re(f.$$.fragment),T(n,"class","ui svelte-efpout"),M(n,"width",e[0]+"px"),T(l,"class","divider svelte-efpout"),T(t,"class","app svelte-efpout")},m(r,a){y(r,t,a),g(t,n),oe(o,n,null),g(n,i),~s&&m[s].m(n,null),g(t,c),g(t,l),g(t,u),oe(f,t,null),d=!0,p||(v=[S(Cn,"mousemove",e[3]),S(Cn,"mouseup",e[4]),S(l,"mousedown",e[2])],p=!0)},p(e,[t]){let r=s;s=x(e),s!==r&&(a&&(J(),ee(m[r],1,1,(()=>{m[r]=null})),K()),~s?(a=m[s],a||(a=m[s]=h[s](e),a.c()),Q(a,1),a.m(n,null)):a=null),(!d||1&t)&&M(n,"width",e[0]+"px")},i(e){d||(Q(o.$$.fragment,e),Q(a),Q(f.$$.fragment,e),d=!0)},o(e){ee(o.$$.fragment,e),ee(a),ee(f.$$.fragment,e),d=!1},d(e){e&&b(t),ie(o),~s&&m[s].d(),ie(f),p=!1,r(v)}}}function Rn(e,t,n){let r;f(e,Te,(e=>n(1,r=e)));let o=832;const i={enabled:!1,initial:0,offset:0};return[o,r,({clientX:e})=>{i.enabled=!0,i.initial=o,i.offset=e},({clientX:e})=>{i.enabled&&(n(0,o=Math.max(Math.floor(i.initial+e-i.offset),500)),O().then((()=>window.dispatchEvent(new Event("resize")))))},()=>{i.enabled&&(i.enabled=!1)}]}class jn extends ae{constructor(e){super(),se(this,e,Rn,Ln,i,{})}}function Nn(e){let t,n;return t=new jn({}),{c(){re(t.$$.fragment)},m(e,r){oe(t,e,r),n=!0},i(e){n||(Q(t.$$.fragment,e),n=!0)},o(e){ee(t.$$.fragment,e),n=!1},d(e){ie(t,e)}}}function In(t){let n;return{c(){n=z("div"),n.innerHTML='Sorry! This works only in <a href="https://www.google.com/chrome/canary/" rel="noopener noreferrer" target="_blank" class="svelte-131274h">Chrome Canary</a>.',T(n,"class","canary svelte-131274h")},m(e,t){y(e,n,t)},i:e,o:e,d(e){e&&b(n)}}}function Gn(t){let n;return{c(){n=z("div"),n.textContent="Loading...",T(n,"class","loading svelte-131274h")},m(e,t){y(e,n,t)},i:e,o:e,d(e){e&&b(n)}}}function Vn(e){let t,n,r,o,i,s,a;const c=[Gn,In,Nn],l=[];function u(e,t){return e[1]?0:e[0]?1:2}return t=u(e),n=l[t]=c[t](e),{c(){n.c(),r=k(),o=z("div"),o.innerHTML='voxeltoy - <a href="https://github.com/danielesteban/voxeltoy" rel="noopener noreferrer" target="_blank" class="svelte-131274h">view source</a><br/> \n  <a href="https://dani.gatunes.com" rel="noopener noreferrer" target="_blank" class="svelte-131274h">dani@gatunes</a>  2022',i=k(),s=z("a"),s.textContent=" Become a sponsor",T(o,"class","info svelte-131274h"),T(s,"class","ribbon svelte-131274h"),T(s,"href","https://github.com/sponsors/danielesteban"),T(s,"data-ribbon"," Become a sponsor"),T(s,"rel","noopener noreferrer"),T(s,"target","_blank")},m(e,n){l[t].m(e,n),y(e,r,n),y(e,o,n),y(e,i,n),y(e,s,n),a=!0},p(e,[o]){let i=t;t=u(e),t!==i&&(J(),ee(l[i],1,1,(()=>{l[i]=null})),K(),n=l[t],n||(n=l[t]=c[t](e),n.c()),Q(n,1),n.m(r.parentNode,r))},i(e){a||(Q(n),a=!0)},o(e){ee(n),a=!1},d(e){l[t].d(e),e&&b(r),e&&b(o),e&&b(i),e&&b(s)}}}function Dn(e,t,n){let r=!1,o=!0;return Promise.all([(async()=>{if(!navigator.gpu||!navigator.gpu.getPreferredCanvasFormat)throw new Error("WebGPU");const e=await navigator.gpu.requestAdapter(),t=await e.requestDevice();return{adapter:e,device:t}})(),new Promise((e=>{require.config({paths:{vs:"https://cdn.jsdelivr.net/npm/monaco-editor@0.33.0/min/vs"}}),require(["vs/editor/editor.main"],e)}))]).then((([e])=>(ge.gpu=e,window.addEventListener("hashchange",Me,!1),Me()))).catch((e=>{console.error(e),n(0,r=!0)})).finally((()=>{n(1,o=!1)})),[r,o]}new class extends ae{constructor(e){super(),se(this,e,Dn,Vn,i,{})}}({target:document.body})}();
