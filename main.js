!function(){"use strict";function e(){}function n(e){return e()}function t(){return Object.create(null)}function r(e){e.forEach(n)}function o(e){return"function"==typeof e}function i(e,n){return e!=e?n==n:e!==n||e&&"object"==typeof e||"function"==typeof e}function s(n,...t){if(null==n)return e;const r=n.subscribe(...t);return r.unsubscribe?()=>r.unsubscribe():r}function a(e){let n;return s(e,(e=>n=e))(),n}function c(e,n,t){e.$$.on_destroy.push(s(n,t))}function l(e,n,t,r){if(e){const o=u(e,n,t,r);return e[0](o)}}function u(e,n,t,r){return e[1]&&r?function(e,n){for(const t in n)e[t]=n[t];return e}(t.ctx.slice(),e[1](r(n))):t.ctx}function f(e,n,t,r){if(e[2]&&r){const o=e[2](r(t));if(void 0===n.dirty)return o;if("object"==typeof o){const e=[],t=Math.max(n.dirty.length,o.length);for(let r=0;r<t;r+=1)e[r]=n.dirty[r]|o[r];return e}return n.dirty|o}return n.dirty}function d(e,n,t,r,o,i){if(o){const s=u(n,t,r,i);e.p(s,o)}}function p(e){if(e.ctx.length>32){const n=[],t=e.ctx.length/32;for(let e=0;e<t;e++)n[e]=-1;return n}return-1}function v(e,n,t){return e.set(t),n}function h(e,n){e.appendChild(n)}function g(e,n,t){e.insertBefore(n,t||null)}function m(e){e.parentNode.removeChild(e)}function x(e,n){for(let t=0;t<e.length;t+=1)e[t]&&e[t].d(n)}function y(e){return document.createElement(e)}function b(e){return document.createTextNode(e)}function w(){return b(" ")}function z(e,n,t,r){return e.addEventListener(n,t,r),()=>e.removeEventListener(n,t,r)}function k(e,n,t){null==t?e.removeAttribute(n):e.getAttribute(n)!==t&&e.setAttribute(n,t)}function $(e){return""===e?null:+e}function S(e,n){n=""+n,e.wholeText!==n&&(e.data=n)}function E(e,n){e.value=null==n?"":n}function M(e,n,t,r){null===t?e.style.removeProperty(n):e.style.setProperty(n,t,r?"important":"")}function T(e,n,t){e.classList[t?"add":"remove"](n)}let _;function P(e){_=e}function C(e){(function(){if(!_)throw new Error("Function called outside component initialization");return _})().$$.on_mount.push(e)}const A=[],B=[],U=[],L=[],R=Promise.resolve();let I=!1;function q(){I||(I=!0,R.then(O))}function V(){return q(),R}function G(e){U.push(e)}const N=new Set;let F=0;function O(){const e=_;do{for(;F<A.length;){const e=A[F];F++,P(e),D(e.$$)}for(P(null),A.length=0,F=0;B.length;)B.pop()();for(let e=0;e<U.length;e+=1){const n=U[e];N.has(n)||(N.add(n),n())}U.length=0}while(A.length);for(;L.length;)L.pop()();I=!1,N.clear(),P(e)}function D(e){if(null!==e.fragment){e.update(),r(e.before_update);const n=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,n),e.after_update.forEach(G)}}const Y=new Set;let j;function X(){j={r:0,c:[],p:j}}function W(){j.r||r(j.c),j=j.p}function Z(e,n){e&&e.i&&(Y.delete(e),e.i(n))}function H(e,n,t,r){if(e&&e.o){if(Y.has(e))return;Y.add(e),j.c.push((()=>{Y.delete(e),r&&(t&&e.d(1),r())})),e.o(n)}else r&&r()}const J="undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;function K(e){e&&e.c()}function Q(e,t,i,s){const{fragment:a,on_mount:c,on_destroy:l,after_update:u}=e.$$;a&&a.m(t,i),s||G((()=>{const t=c.map(n).filter(o);l?l.push(...t):r(t),e.$$.on_mount=[]})),u.forEach(G)}function ee(e,n){const t=e.$$;null!==t.fragment&&(r(t.on_destroy),t.fragment&&t.fragment.d(n),t.on_destroy=t.fragment=null,t.ctx=[])}function ne(n,o,i,s,a,c,l,u=[-1]){const f=_;P(n);const d=n.$$={fragment:null,ctx:null,props:c,update:e,not_equal:a,bound:t(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(o.context||(f?f.$$.context:[])),callbacks:t(),dirty:u,skip_bound:!1,root:o.target||f.$$.root};l&&l(d.root);let p=!1;if(d.ctx=i?i(n,o.props||{},((e,t,...r)=>{const o=r.length?r[0]:t;return d.ctx&&a(d.ctx[e],d.ctx[e]=o)&&(!d.skip_bound&&d.bound[e]&&d.bound[e](o),p&&function(e,n){-1===e.$$.dirty[0]&&(A.push(e),q(),e.$$.dirty.fill(0)),e.$$.dirty[n/31|0]|=1<<n%31}(n,e)),t})):[],d.update(),p=!0,r(d.before_update),d.fragment=!!s&&s(d.ctx),o.target){if(o.hydrate){const e=function(e){return Array.from(e.childNodes)}(o.target);d.fragment&&d.fragment.l(e),e.forEach(m)}else d.fragment&&d.fragment.c();o.intro&&Z(n.$$.fragment),Q(n,o.target,o.anchor,o.customElement),O()}P(f)}class te{$destroy(){ee(this,1),this.$destroy=e}$on(e,n){const t=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return t.push(n),()=>{const e=t.indexOf(n);-1!==e&&t.splice(e,1)}}$set(e){var n;this.$$set&&(n=e,0!==Object.keys(n).length)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}const re=[];function oe(n,t=e){let r;const o=new Set;function s(e){if(i(n,e)&&(n=e,r)){const e=!re.length;for(const e of o)e[1](),re.push(e,n);if(e){for(let e=0;e<re.length;e+=2)re[e][0](re[e+1]);re.length=0}}}return{set:s,update:function(e){s(e(n))},subscribe:function(i,a=e){const c=[i,a];return o.add(c),1===o.size&&(r=t(s)||e),i(n),()=>{o.delete(c),0===o.size&&(r(),r=null)}}}}const ie={errors:oe([]),source:oe("fn getColorAt(texture : i32, pixel : vec2<i32>) -> vec4<f32> {\n  var h : f32 = f32(texture) / f32(atlas.count);\n  var s : f32 = 0.5;\n  var l : f32 = 0.5;\n  if (\n    pixel.x == 0 || pixel.x == (atlas.width - 1)\n    || pixel.y == 0 || pixel.y == (atlas.height - 1)\n  ) {\n    l = min(l * 1.1, 1);\n  }\n  return hsl2Rgba(h, s, l);\n}\n")},se=["// VoxelToy\n\n// SDF primitives\n// sdBox(p : vec3<f32>, r : vec3<f32>) -> f32\n// sdCapsule(p : vec3<f32>, r : vec3<f32>) -> f32\n// sdEllipsoid(p : vec3<f32>, r : vec3<f32>) -> f32\n// sdSphere(p : vec3<f32>, r : f32) -> f32\n// sdTorus(p : vec3<f32>, r : vec2<f32>) -> f32\n\n// SDF operations\n// opUnion(d1 : f32, d2 : f32) -> f32\n// opSubstraction(d1 : f32, d2 : f32) -> f32\n// opSmoothUnion(d1 : f32, d2 : f32, k : f32) -> f32\n// opSmoothSubstraction(d1 : f32, d2 : f32, k : f32) -> f32\n\n// Noise functions\n// noise3(p: vec3<f32>) -> f32\n// simplexNoise3(v: vec3<f32>) -> f32\n\n// Rotation helpers\n// rotateX(rad : f32) -> mat3x3<f32>\n// rotateY(rad : f32) -> mat3x3<f32>\n// rotateZ(rad : f32) -> mat3x3<f32>\n\n// Variables\n// time : f32\n// volume.size : vec3<f32>\n// volume.center : vec3<f32>\n\nfn distanceToScene(pos : vec3<f32>) -> f32 {\n  var origin : vec3<f32> = pos - volume.center;\n  var t : f32 = sin(time * 2);\n  var size : f32 = volume.size.x * (0.25 + t * 0.01);\n  return opSmoothUnion(\n    sdSphere(origin - vec3<f32>(size * (0.6 * t * -1), size * 0.2 * t * -1, 0), size),\n    sdSphere(origin - vec3<f32>(size * (0.6 * t), size * 0.2 * t, 0), size),\n    10\n  );\n}\n\nfn getValueAt(pos : vec3<f32>) -> f32 {\n  if (distanceToScene(pos) > 0.01) {\n    return 0;\n  }\n  return 1 + abs(simplexNoise3(pos * 0.01)) * 254;\n}\n","fn distanceToScene(pos : vec3<f32>) -> f32 {\n  var origin : vec3<f32> = pos - volume.center;\n  var r : mat3x3<f32> = rotateX(PI * -0.5);\n  return opUnion(\n    sdTorus(\n      r * origin,\n      vec2<f32>(volume.size.x * 0.3, volume.size.x * 0.1)\n    ),\n    sdTorus(\n      r * rotateY(time) * origin,\n      vec2<f32>(volume.size.x * 0.1, volume.size.x * (0.02 + sin(time * 10) * 0.01))\n    )\n  );\n}\n\nfn getValueAt(pos : vec3<f32>) -> f32 {\n  if (distanceToScene(pos) > 0.01) {\n    return 0;\n  }\n  return 1 + abs(simplexNoise3(pos * 0.01)) * 254;\n}\n","fn getValueAt(pos : vec3<f32>) -> f32 {\n  var p : vec3<f32> = pos + vec3<f32>(0, 0, round(time * 100));\n  var h : f32 = abs(simplexNoise3(p * 0.01)) * volume.size.y;\n  if (pos.y > h) {\n    return 0;\n  }\n  return 1 + abs(simplexNoise3(p * -0.001)) * 254;\n}\n","fn distanceToScene(pos : vec3<f32>) -> f32 {\n  if (sdSphere(pos - volume.center, volume.size.x * 0.35) > 0.01) {\n    return 1;\n  }\n  var id : f32 = noise3(floor(pos / 32));\n  var p : vec3<f32> = (pos % 32) - 16;\n  var t : f32 = sin((time + id) * 4);\n  var d : f32;\n  if (floor(id * 10) % 2 == 0) {\n    d = sdSphere(p, t * 4 + 8);\n  } else {\n    d = sdBox(p, vec3<f32>(t * 4 + 8));\n  }\n  return opSmoothSubstraction(\n    opSmoothSubstraction(\n      d,\n      sdBox(p, vec3<f32>(4, 4, 12)),\n      1\n    ),\n    sdBox(p, vec3<f32>(12, 4, 4)),\n    1\n  );\n}\n\nfn getValueAt(pos : vec3<f32>) -> f32 {\n  if (distanceToScene(pos) > 0.01) {\n    return 0;\n  }\n  return 1 + abs(simplexNoise3(floor(pos / 32))) * 254;\n}\n"],ae={background:oe("#000000"),effects:{edges:{color:oe("#000000"),intensity:oe(.3)}},gpu:null,resolution:oe(300)},ce={errors:oe([]),source:oe(se[0])},le=oe("scene");function ue(e,n,t){const r=e.slice();return r[11]=n[t].lineNum,r[12]=n[t].linePos,r[13]=n[t].type,r[14]=n[t].message,r[15]=n[t].line,r[16]=n[t].pointer,r}function fe(e){let n,t,r,o,i,s,a,c,l,u,f,d,p,v,x,z,$,E=e[11]+"",M=e[12]+"",T=e[13]+"",_=e[14]+"",P=e[15]+"",C=e[16]+"";return{c(){n=y("div"),t=y("div"),r=b(":"),o=b(E),i=b(":"),s=b(M),a=w(),c=b(T),l=b(": "),u=b(_),f=w(),d=y("div"),p=b(P),v=w(),x=y("div"),z=b(C),$=w(),k(t,"class","svelte-gxob7"),k(d,"class","svelte-gxob7"),k(x,"class","svelte-gxob7"),k(n,"class","svelte-gxob7")},m(e,m){g(e,n,m),h(n,t),h(t,r),h(t,o),h(t,i),h(t,s),h(t,a),h(t,c),h(t,l),h(t,u),h(n,f),h(n,d),h(d,p),h(n,v),h(n,x),h(x,z),h(n,$)},p(e,n){4&n&&E!==(E=e[11]+"")&&S(o,E),4&n&&M!==(M=e[12]+"")&&S(s,M),4&n&&T!==(T=e[13]+"")&&S(c,T),4&n&&_!==(_=e[14]+"")&&S(u,_),4&n&&P!==(P=e[15]+"")&&S(p,P),4&n&&C!==(C=e[16]+"")&&S(z,C)},d(e){e&&m(n)}}}function de(n){let t,r,o,i,s,a,c,l,u,f,d,p,v,$,E=n[2].length+"",M=n[2],_=[];for(let e=0;e<M.length;e+=1)_[e]=fe(ue(n,M,e));return{c(){t=y("div"),r=y("div"),o=w(),i=y("div"),s=y("div"),a=y("div"),c=w(),l=b(E),u=b(" errors\n      "),f=y("div"),d=w(),p=y("div");for(let e=0;e<_.length;e+=1)_[e].c();k(r,"class","wrapper svelte-gxob7"),k(a,"class","status svelte-gxob7"),T(a,"error",n[2].length),k(f,"class","arrow svelte-gxob7"),k(s,"class","toggle svelte-gxob7"),k(p,"class","messages svelte-gxob7"),k(i,"class","errors svelte-gxob7"),T(i,"open",n[1]),k(t,"class","editor svelte-gxob7")},m(e,m){g(e,t,m),h(t,r),n[7](r),h(t,o),h(t,i),h(i,s),h(s,a),h(s,c),h(s,l),h(s,u),h(s,f),h(i,d),h(i,p);for(let e=0;e<_.length;e+=1)_[e].m(p,null);v||($=z(s,"click",n[5]),v=!0)},p(e,[n]){if(4&n&&T(a,"error",e[2].length),4&n&&E!==(E=e[2].length+"")&&S(l,E),4&n){let t;for(M=e[2],t=0;t<M.length;t+=1){const r=ue(e,M,t);_[t]?_[t].p(r,n):(_[t]=fe(r),_[t].c(),_[t].m(p,null))}for(;t<_.length;t+=1)_[t].d(1);_.length=M.length}2&n&&T(i,"open",e[1])},i:e,o:e,d(e){e&&m(t),n[7](null),x(_,e),v=!1,$()}}}const pe=new Map;function ve(e,n,t){let r,o,{state:i}=n;const{errors:s,source:a}=i;let l,u;c(e,s,(e=>t(2,o=e))),c(e,a,(e=>t(9,r=e)));let f=!1;const d=()=>u.layout();return C((()=>{let e,n=!0;if(u=monaco.editor.create(l,{minimap:{enabled:!1},theme:"vs-dark"}),pe.has(a)){const{model:e,view:n}=pe.get(a);u.setModel(e),u.restoreViewState(n)}else u.setModel(monaco.editor.createModel(r,"c"));const t=[s.subscribe((e=>{monaco.editor.setModelMarkers(u.getModel(),"Errors",e.map((({lineNum:e,linePos:n,length:t,message:r})=>({message:r,startLineNumber:e,endLineNumber:e,startColumn:n,endColumn:n+t}))))})),a.subscribe((e=>{n||u.setValue(e)}))];return n=!1,u.onDidChangeModelContent((()=>{e&&clearTimeout(e),e=setTimeout((()=>{n=!0,a.set(u.getValue()),n=!1}),300)})),window.addEventListener("resize",d,!1),()=>{pe.set(a,{model:u.getModel(),view:u.saveViewState()}),u.dispose(),clearTimeout(e),window.removeEventListener("resize",d),t.forEach((e=>e()))}})),e.$$set=e=>{"state"in e&&t(6,i=e.state)},[l,f,o,s,a,()=>{t(1,f=!f),V().then(d)},i,function(e){B[e?"unshift":"push"]((()=>{l=e,t(0,l)}))}]}class he extends te{constructor(e){super(),ne(this,e,ve,de,i,{state:6})}}function ge(n){let t,r;return t=new he({props:{state:ie}}),{c(){K(t.$$.fragment)},m(e,n){Q(t,e,n),r=!0},p:e,i(e){r||(Z(t.$$.fragment,e),r=!0)},o(e){H(t.$$.fragment,e),r=!1},d(e){ee(t,e)}}}class me extends te{constructor(e){super(),ne(this,e,null,ge,i,{})}}function xe(e,n,t){const r=e.slice();return r[13]=n[t],r}function ye(e){let n,t,r,o,i,s,a=e[13]+"";return{c(){n=y("div"),t=b(a),r=y("span"),r.textContent="3",o=w(),k(r,"class","svelte-1rqdw4a"),k(n,"class","svelte-1rqdw4a"),T(n,"enabled",e[13]===e[0])},m(a,c){g(a,n,c),h(n,t),h(n,r),h(n,o),i||(s=z(n,"click",e[9](e[13])),i=!0)},p(t,r){e=t,257&r&&T(n,"enabled",e[13]===e[0])},d(e){e&&m(n),i=!1,s()}}}function be(n){let t,o,i,s,a,c,l,u,f,d,p,v,b,S,M,T,_,P,C,A,B,U,L,R,I,q,V=n[8],G=[];for(let e=0;e<V.length;e+=1)G[e]=ye(xe(n,V,e));return{c(){t=y("div"),o=y("div"),i=y("label"),i.textContent="Background:",s=w(),a=y("input"),c=w(),l=y("div"),u=y("label"),u.textContent="Resolution:",f=w(),d=y("div");for(let e=0;e<G.length;e+=1)G[e].c();p=w(),v=y("h4"),v.textContent="Effects",b=w(),S=y("h5"),S.textContent="Edges",M=w(),T=y("div"),_=y("label"),_.textContent="Color:",P=w(),C=y("input"),A=w(),B=y("div"),U=y("label"),U.textContent="Intensity:",L=w(),R=y("input"),k(i,"for","background"),k(i,"class","svelte-1rqdw4a"),k(a,"id","background"),k(a,"type","color"),k(a,"class","svelte-1rqdw4a"),k(o,"class","input svelte-1rqdw4a"),k(u,"for","resolution"),k(u,"class","svelte-1rqdw4a"),k(d,"class","resolution svelte-1rqdw4a"),k(l,"class","input svelte-1rqdw4a"),k(v,"class","svelte-1rqdw4a"),k(S,"class","svelte-1rqdw4a"),k(_,"for","edgesColor"),k(_,"class","svelte-1rqdw4a"),k(C,"id","edgesColor"),k(C,"type","color"),k(C,"class","svelte-1rqdw4a"),k(T,"class","input svelte-1rqdw4a"),k(U,"for","edgesIntensity"),k(U,"class","svelte-1rqdw4a"),k(R,"id","edgesIntensity"),k(R,"type","number"),k(R,"min",0),k(R,"max",1),k(R,"step",.01),k(R,"class","svelte-1rqdw4a"),k(B,"class","input svelte-1rqdw4a"),k(t,"class","wrapper svelte-1rqdw4a")},m(e,r){g(e,t,r),h(t,o),h(o,i),h(o,s),h(o,a),E(a,n[1]),h(t,c),h(t,l),h(l,u),h(l,f),h(l,d);for(let e=0;e<G.length;e+=1)G[e].m(d,null);h(t,p),h(t,v),h(t,b),h(t,S),h(t,M),h(t,T),h(T,_),h(T,P),h(T,C),E(C,n[2]),h(t,A),h(t,B),h(B,U),h(B,L),h(B,R),E(R,n[3]),I||(q=[z(a,"input",n[10]),z(C,"input",n[11]),z(R,"input",n[12])],I=!0)},p(e,[n]){if(2&n&&E(a,e[1]),769&n){let t;for(V=e[8],t=0;t<V.length;t+=1){const r=xe(e,V,t);G[t]?G[t].p(r,n):(G[t]=ye(r),G[t].c(),G[t].m(d,null))}for(;t<G.length;t+=1)G[t].d(1);G.length=V.length}4&n&&E(C,e[2]),8&n&&$(R.value)!==e[3]&&E(R,e[3])},i:e,o:e,d(e){e&&m(t),x(G,e),I=!1,r(q)}}}function we(e,n,t){let r,o,i,s;const{background:a,effects:{edges:{color:l,intensity:u}},resolution:f}=ae;c(e,a,(e=>t(1,o=e))),c(e,l,(e=>t(2,i=e))),c(e,u,(e=>t(3,s=e))),c(e,f,(e=>t(0,r=e)));return[r,o,i,s,a,l,u,f,[100,200,300,400],e=>()=>{v(f,r=e,r)},function(){o=this.value,a.set(o)},function(){i=this.value,l.set(i)},function(){s=$(this.value),u.set(s)}]}class ze extends te{constructor(e){super(),ne(this,e,we,be,i,{})}}function ke(n){let t,r;return t=new he({props:{state:ce}}),{c(){K(t.$$.fragment)},m(e,n){Q(t,e,n),r=!0},p:e,i(e){r||(Z(t.$$.fragment,e),r=!0)},o(e){H(t.$$.fragment,e),r=!1},d(e){ee(t,e)}}}class $e extends te{constructor(e){super(),ne(this,e,null,ke,i,{})}}const Se=e=>({}),Ee=e=>({}),Me=e=>({}),Te=e=>({});function _e(e){let n,t,r,o;const i=e[1].toggle,s=l(i,e,e[0],Te),a=e[1].options,c=l(a,e,e[0],Ee);return{c(){n=y("div"),s&&s.c(),t=w(),r=y("div"),c&&c.c(),k(r,"class","options svelte-stktq6"),k(n,"class","dropdown svelte-stktq6")},m(e,i){g(e,n,i),s&&s.m(n,null),h(n,t),h(n,r),c&&c.m(r,null),o=!0},p(e,[n]){s&&s.p&&(!o||1&n)&&d(s,i,e,e[0],o?f(i,e[0],n,Me):p(e[0]),Te),c&&c.p&&(!o||1&n)&&d(c,a,e,e[0],o?f(a,e[0],n,Se):p(e[0]),Ee)},i(e){o||(Z(s,e),Z(c,e),o=!0)},o(e){H(s,e),H(c,e),o=!1},d(e){e&&m(n),s&&s.d(e),c&&c.d(e)}}}function Pe(e,n,t){let{$$slots:r={},$$scope:o}=n;return e.$$set=e=>{"$$scope"in e&&t(0,o=e.$$scope)},[o,r]}class Ce extends te{constructor(e){super(),ne(this,e,Pe,_e,i,{})}}function Ae(e,n,t){const r=e.slice();return r[11]=n[t],r[13]=t,r}function Be(e,n,t){const r=e.slice();return r[14]=n[t].id,r[15]=n[t].name,r}function Ue(e){let n,t,r,o,i,s=e[15]+"";return{c(){n=y("div"),t=b(s),r=w(),k(n,"class","tool svelte-g0n6kb"),T(n,"enabled",e[2]===e[14])},m(s,a){g(s,n,a),h(n,t),h(n,r),o||(i=z(n,"click",e[4](e[14])),o=!0)},p(t,r){e=t,12&r&&T(n,"enabled",e[2]===e[14])},d(e){e&&m(n),o=!1,i()}}}function Le(e){let n,t;return n=new Ce({props:{$$slots:{options:[qe],toggle:[Re]},$$scope:{ctx:e}}}),{c(){K(n.$$.fragment)},m(e,r){Q(n,e,r),t=!0},p(e,t){const r={};262144&t&&(r.$$scope={dirty:t,ctx:e}),n.$set(r)},i(e){t||(Z(n.$$.fragment,e),t=!0)},o(e){H(n.$$.fragment,e),t=!1},d(e){ee(n,e)}}}function Re(n){let t;return{c(){t=y("div"),t.innerHTML='Load Example\n          <div class="arrow svelte-g0n6kb"></div>',k(t,"class","toggle svelte-g0n6kb"),k(t,"slot","toggle")},m(e,n){g(e,t,n)},p:e,d(e){e&&m(t)}}}function Ie(e){let n,t,r,o,i,s=e[13]+1+"";return{c(){n=y("div"),t=b("Example "),r=b(s),k(n,"class","action svelte-g0n6kb")},m(s,a){g(s,n,a),h(n,t),h(n,r),o||(i=z(n,"click",e[5](e[11])),o=!0)},p(n,t){e=n},d(e){e&&m(n),o=!1,i()}}}function qe(e){let n,t=se,r=[];for(let n=0;n<t.length;n+=1)r[n]=Ie(Ae(e,t,n));return{c(){for(let e=0;e<r.length;e+=1)r[e].c();n=b("")},m(e,t){for(let n=0;n<r.length;n+=1)r[n].m(e,t);g(e,n,t)},p(e,o){if(32&o){let i;for(t=se,i=0;i<t.length;i+=1){const s=Ae(e,t,i);r[i]?r[i].p(s,o):(r[i]=Ie(s),r[i].c(),r[i].m(n.parentNode,n))}for(;i<r.length;i+=1)r[i].d(1);r.length=t.length}},d(e){x(r,e),e&&m(n)}}}function Ve(e){let n,t,o,i,s,a,c,l,u,f,d,p,v,b,$,S,E=e[3],M=[];for(let n=0;n<E.length;n+=1)M[n]=Ue(Be(e,E,n));let T="scene"===e[2]&&Le(e);return{c(){n=y("div"),t=y("input"),o=w(),i=y("a"),s=w(),a=y("div"),c=y("div");for(let e=0;e<M.length;e+=1)M[e].c();l=w(),u=y("div"),T&&T.c(),f=w(),d=y("div"),d.textContent="Import",p=w(),v=y("div"),v.textContent="Export",k(t,"type","file"),k(t,"accept","application/json"),k(n,"class","helpers svelte-g0n6kb"),k(c,"class","tools svelte-g0n6kb"),k(d,"class","svelte-g0n6kb"),k(v,"class","svelte-g0n6kb"),k(u,"class","actions svelte-g0n6kb"),k(a,"class","toolbar svelte-g0n6kb")},m(r,m){g(r,n,m),h(n,t),e[9](t),h(n,o),h(n,i),e[10](i),g(r,s,m),g(r,a,m),h(a,c);for(let e=0;e<M.length;e+=1)M[e].m(c,null);h(a,l),h(a,u),T&&T.m(u,null),h(u,f),h(u,d),h(u,p),h(u,v),b=!0,$||(S=[z(t,"change",e[7]),z(d,"click",e[6]),z(v,"click",e[8])],$=!0)},p(e,[n]){if(28&n){let t;for(E=e[3],t=0;t<E.length;t+=1){const r=Be(e,E,t);M[t]?M[t].p(r,n):(M[t]=Ue(r),M[t].c(),M[t].m(c,null))}for(;t<M.length;t+=1)M[t].d(1);M.length=E.length}"scene"===e[2]?T?(T.p(e,n),4&n&&Z(T,1)):(T=Le(e),T.c(),Z(T,1),T.m(u,f)):T&&(X(),H(T,1,1,(()=>{T=null})),W())},i(e){b||(Z(T),b=!0)},o(e){H(T),b=!1},d(t){t&&m(n),e[9](null),e[10](null),t&&m(s),t&&m(a),x(M,t),T&&T.d(),$=!1,r(S)}}}function Ge(e,n,t){let r,o,i;c(e,le,(e=>t(2,r=e)));return[o,i,r,[{id:"scene",name:"Scene"},{id:"atlas",name:"Atlas"},{id:"rendering",name:"Rendering"}],e=>()=>{v(le,r=e,r)},e=>()=>ce.source.set(e),()=>o.click(),()=>{const e=o.files[0];if(!e)return;const n=new FileReader;n.addEventListener("load",(()=>{var e;"string"==typeof(e=n.result)&&(e=JSON.parse(e)),ie.source.set(e.atlas),ae.background.set(`#${("000000"+e.background.toString(16)).slice(-6)}`),ae.effects.edges.color.set(`#${("000000"+e.edgesColor.toString(16)).slice(-6)}`),ae.effects.edges.intensity.set(e.edgesIntensity),ae.resolution.set(e.resolution),ce.source.set(e.scene),t(0,o.value=null,o)}),!1),n.readAsText(e)},()=>{const e=new Blob([JSON.stringify({atlas:a(ie.source),background:parseInt(a(ae.background).slice(1),16),edgesColor:parseInt(a(ae.effects.edges.color).slice(1),16),edgesIntensity:a(ae.effects.edges.intensity),resolution:a(ae.resolution),scene:a(ce.source)})],{type:"application/json"});t(1,i.download="scene.json",i),t(1,i.href=URL.createObjectURL(e),i),i.click()},function(e){B[e?"unshift":"push"]((()=>{o=e,t(0,o)}))},function(e){B[e?"unshift":"push"]((()=>{i=e,t(1,i)}))}]}class Ne extends te{constructor(e){super(),ne(this,e,Ge,Ve,i,{})}}var Fe=1e-6,Oe="undefined"!=typeof Float32Array?Float32Array:Array,De=Math.PI/180;function Ye(){var e=new Oe(16);return Oe!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function je(e,n,t,r){var o=n[0],i=n[1],s=n[2],a=n[3],c=o+o,l=i+i,u=s+s,f=o*c,d=o*l,p=o*u,v=i*l,h=i*u,g=s*u,m=a*c,x=a*l,y=a*u,b=r[0],w=r[1],z=r[2];return e[0]=(1-(v+g))*b,e[1]=(d+y)*b,e[2]=(p-x)*b,e[3]=0,e[4]=(d-y)*w,e[5]=(1-(f+g))*w,e[6]=(h+m)*w,e[7]=0,e[8]=(p+x)*z,e[9]=(h-m)*z,e[10]=(1-(f+v))*z,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)});var Xe=function(e,n,t,r,o){var i,s=1/Math.tan(n/2);return e[0]=s/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(i=1/(r-o),e[10]=(o+r)*i,e[14]=2*o*r*i):(e[10]=-1,e[14]=-2*r),e};function We(){var e=new Oe(3);return Oe!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Ze(e,n,t,r){return e[0]=n,e[1]=t,e[2]=r,e}function He(){var e=new Oe(2);return Oe!=Float32Array&&(e[0]=0,e[1]=0),e}function Je(e,n){var t=new Oe(2);return t[0]=e,t[1]=n,t}function Ke(e,n,t){return e[0]=n,e[1]=t,e}We(),function(){var e=He()}();var Qe="fn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn noise3(p: vec3<f32>) -> f32 {\n  let a = floor(p);\n  var d: vec3<f32> = p - a;\n  d = d * d * (3. - 2. * d);\n\n  let b = a.xxyy + vec4<f32>(0., 1., 0., 1.);\n  let k1 = permute4(b.xyxy);\n  let k2 = permute4(k1.xyxy + b.zzww);\n\n  let c = k2 + a.zzzz;\n  let k3 = permute4(c);\n  let k4 = permute4(c + 1.);\n\n  let o1 = fract(k3 * (1. / 41.));\n  let o2 = fract(k4 * (1. / 41.));\n\n  let o3 = o2 * d.z + o1 * (1. - d.z);\n  let o4 = o3.yw * d.x + o3.xz * (1. - d.x);\n\n  return o4.y * d.y + o4.x * (1. - d.y);\n}\n\nfn simplexNoise3(v: vec3<f32>) -> f32 {\n  let C = vec2<f32>(1. / 6., 1. / 3.);\n  let D = vec4<f32>(0., 0.5, 1., 2.);\n\n  var i: vec3<f32>  = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  let x1 = x0 - i1 + 1. * C.xxx;\n  let x2 = x0 - i2 + 2. * C.xxx;\n  let x3 = x0 - 1. + 3. * C.xxx;\n\n  i = i % vec3<f32>(289.);\n  let p = permute4(permute4(permute4(\n      i.z + vec4<f32>(0., i1.z, i2.z, 1. )) +\n      i.y + vec4<f32>(0., i1.y, i2.y, 1. )) +\n      i.x + vec4<f32>(0., i1.x, i2.x, 1. ));\n\n  var n_: f32 = 1. / 7.;\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49. * floor(p * ns.z * ns.z);\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_);\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = 1.0 - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  let s0 = floor(b0)*2.0 + 1.0;\n  let s1 = floor(b1)*2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  var p0: vec3<f32> = vec3<f32>(a0.xy, h.x);\n  var p1: vec3<f32> = vec3<f32>(a0.zw, h.y);\n  var p2: vec3<f32> = vec3<f32>(a1.xy, h.z);\n  var p3: vec3<f32> = vec3<f32>(a1.zw, h.w);\n\n  let norm = taylorInvSqrt4(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 = p0 * norm.x;\n  p1 = p1 * norm.y;\n  p2 = p2 * norm.z;\n  p3 = p3 * norm.w;\n\n  var m: vec4<f32> = 0.6 - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  m = max(m, vec4<f32>(0.));\n  m = m * m;\n  return 42. * dot(m * m, vec4<f32>(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n";class en{constructor({device:e,count:n=254,width:t=16,height:r=16}){this.device=e,this.count=n,this.width=t,this.height=r,this.texture=e.createTexture({dimension:"2d",size:[t,r,n],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING})}compute(e="\nfn getColorAt(texture : i32, pixel : vec2<i32>) -> vec4<f32> {\n  var h : f32 = f32(texture) / f32(atlas.count);\n  var s : f32 = 0.5;\n  var l : f32 = 0.5;\n  if (pixel.x == 0 || pixel.y == 0 || pixel.x == (atlas.width - 1) || pixel.y == (atlas.height - 1)) {\n    l = min(l * 1.1, 1);\n  }\n  return hsl2Rgba(h, s, l);\n}\n"){if(this.generator===e)return;this.generator=e;const{device:n,count:t,width:r,height:o,texture:i}=this;this.code=(({count:e,width:n,height:t,generator:r})=>`\n@group(0) @binding(0) var texture : texture_storage_2d_array<rgba8unorm, write>;\n\n${Qe}\n\nstruct Atlas {\n  count : i32,\n  width : i32,\n  height : i32,\n  stride : i32,\n  length : i32,\n}\n\nconst atlas : Atlas = Atlas(\n  ${e},\n  ${n},\n  ${t},\n  ${n*t},\n  ${e*n*t},\n);\n\nfn hue2Rgb(p : f32, q : f32, t : f32) -> f32 {\n  var h : f32 = t;\n  if (h < 0) { h += 1; }\n  if (h > 1) { h -= 1; }\n  if (h < 1 / 6.0) { return p + (q - p) * 6 * h; }\n  if (h < 1 / 2.0) { return q; }\n  if (h < 2 / 3.0) { return p + (q - p) * (2.0 / 3.0 - h) * 6; }\n  return p;\n}\n\nfn hsl2Rgba(h : f32, s: f32, l: f32) -> vec4<f32> {\n  var rgba : vec4<f32> = vec4<f32>(0, 0, 0, 1);\n  if (s == 0) {\n    rgba.r = l;\n    rgba.g = l;\n    rgba.b = l;\n  } else {\n    var q : f32;\n    if (l < 0.5) {\n      q = l * (1 + s);\n    } else {\n      q = l + s - l * s;\n    }\n    var p : f32 = 2 * l - q;\n    rgba.r = hue2Rgb(p, q, h + 1 / 3.0);\n    rgba.g = hue2Rgb(p, q, h);\n    rgba.b = hue2Rgb(p, q, h - 1 / 3.0);\n  }\n  return rgba;\n};\n\n${r}\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var id : i32 = i32(GlobalInvocationID.x);\n  if (id >= atlas.length) {\n    return;\n  }\n  var tex : i32 = id / atlas.stride;\n  var index : i32 = id - tex * atlas.stride;\n  var y : i32 = index / atlas.width;\n  var pixel : vec2<i32> = vec2<i32>(index - y * atlas.width, y);\n  textureStore(texture, pixel, tex, getColorAt(tex, pixel));\n}\n`)({count:t,width:r,height:o,generator:e}),this.shader=n.createShaderModule({code:this.code});const s=n.createComputePipeline({layout:"auto",compute:{module:this.shader,entryPoint:"main"}}),a=n.createCommandEncoder(),c=a.beginComputePass();c.setPipeline(s),c.setBindGroup(0,n.createBindGroup({layout:s.getBindGroupLayout(0),entries:[{binding:0,resource:i.createView()}]})),c.dispatchWorkgroups(Math.ceil(t*r*o/64)),c.end(),n.queue.submit([a.finish()])}}const nn=Ye(),tn=We(),rn=function(e,n,t){var r=new Oe(3);return r[0]=e,r[1]=n,r[2]=t,r}(0,1,0);class on{constructor({device:e,aspect:n=1,fov:t=75,near:r=.1,far:o=1e3}){this.device=e,this.buffer=e.createBuffer({size:41*Float32Array.BYTES_PER_ELEMENT+12,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=n,this.fov=t,this.near=r,this.far=o,this.position=We(),this.target=We(),this.projectionMatrix=Ye(),this.viewBuffer=new Float32Array(25),this.viewMatrix=this.viewBuffer.subarray(0,16),this.normalMatrix=this.viewBuffer.subarray(16,25)}setOrbit(e,n,t){const{position:r,target:o}=this,i=Math.sin(e)*t;(function(e,n,t){e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2]})(r,o,Ze(tn,i*Math.sin(n),Math.cos(e)*t,i*Math.cos(n))),this.updateView()}updateProjection(){const{device:e,buffer:n,projectionMatrix:t,aspect:r,fov:o,near:i,far:s}=this;Xe(t,function(e){return e*De}(o),r,i,s),e.queue.writeBuffer(n,0,t)}updateView(){const{device:e,buffer:n,viewBuffer:t,viewMatrix:r,normalMatrix:o,position:i,target:s}=this;var a,c,l,u,f,d,p,v,h,g,m,x,y,b,w,z,k,$,S,E,M,T,_;a=r,l=s,u=rn,w=(c=i)[0],z=c[1],k=c[2],$=u[0],S=u[1],E=u[2],M=l[0],T=l[1],_=l[2],Math.abs(w-M)<Fe&&Math.abs(z-T)<Fe&&Math.abs(k-_)<Fe?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(a):(m=w-M,x=z-T,y=k-_,f=S*(y*=b=1/Math.hypot(m,x,y))-E*(x*=b),d=E*(m*=b)-$*y,p=$*x-S*m,(b=Math.hypot(f,d,p))?(f*=b=1/b,d*=b,p*=b):(f=0,d=0,p=0),v=x*p-y*d,h=y*f-m*p,g=m*d-x*f,(b=Math.hypot(v,h,g))?(v*=b=1/b,h*=b,g*=b):(v=0,h=0,g=0),a[0]=f,a[1]=v,a[2]=m,a[3]=0,a[4]=d,a[5]=h,a[6]=x,a[7]=0,a[8]=p,a[9]=g,a[10]=y,a[11]=0,a[12]=-(f*w+d*z+p*k),a[13]=-(v*w+h*z+g*k),a[14]=-(m*w+x*z+y*k),a[15]=1),function(e,n){var t=n[0],r=n[1],o=n[2],i=n[3],s=n[4],a=n[5],c=n[6],l=n[7],u=n[8],f=n[9],d=n[10],p=n[11],v=n[12],h=n[13],g=n[14],m=n[15],x=t*a-r*s,y=t*c-o*s,b=t*l-i*s,w=r*c-o*a,z=r*l-i*a,k=o*l-i*c,$=u*h-f*v,S=u*g-d*v,E=u*m-p*v,M=f*g-d*h,T=f*m-p*h,_=d*m-p*g,P=x*_-y*T+b*M+w*E-z*S+k*$;P&&(P=1/P,e[0]=(a*_-c*T+l*M)*P,e[1]=(c*E-s*_-l*S)*P,e[2]=(s*T-a*E+l*$)*P,e[3]=(o*T-r*_-i*M)*P,e[4]=(t*_-o*E+i*S)*P,e[5]=(r*E-t*T-i*$)*P,e[6]=(h*k-g*z+m*w)*P,e[7]=(g*b-v*k-m*y)*P,e[8]=(v*z-h*b+m*x)*P)}(o,function(e,n){var t=n[0],r=n[1],o=n[2],i=n[3],s=n[4],a=n[5],c=n[6],l=n[7],u=n[8],f=n[9],d=n[10],p=n[11],v=n[12],h=n[13],g=n[14],m=n[15],x=t*a-r*s,y=t*c-o*s,b=t*l-i*s,w=r*c-o*a,z=r*l-i*a,k=o*l-i*c,$=u*h-f*v,S=u*g-d*v,E=u*m-p*v,M=f*g-d*h,T=f*m-p*h,_=d*m-p*g,P=x*_-y*T+b*M+w*E-z*S+k*$;return P?(P=1/P,e[0]=(a*_-c*T+l*M)*P,e[1]=(o*T-r*_-i*M)*P,e[2]=(h*k-g*z+m*w)*P,e[3]=(d*z-f*k-p*w)*P,e[4]=(c*E-s*_-l*S)*P,e[5]=(t*_-o*E+i*S)*P,e[6]=(g*b-v*k-m*y)*P,e[7]=(u*k-d*b+p*y)*P,e[8]=(s*T-a*E+l*$)*P,e[9]=(r*E-t*T-i*$)*P,e[10]=(v*z-h*b+m*x)*P,e[11]=(f*b-u*z-p*x)*P,e[12]=(a*S-s*M-c*$)*P,e[13]=(t*M-r*S+o*$)*P,e[14]=(h*y-v*w-g*x)*P,e[15]=(u*w-f*y+d*x)*P,e):null}(nn,r)),e.queue.writeBuffer(n,64,t)}}var sn="const PI : f32 = 3.141592653589793;\n\nfn rotateX(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    1, 0, 0,\n    0, c, s,\n    0, -s, c,\n  );\n}\n\nfn rotateY(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c,\n  );\n}\n\nfn rotateZ(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, s, 0,\n    -s, c, 0,\n    0, 0, 1,\n  );\n}\n";class an{constructor({device:e,format:n}){this.device=e,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},this.effects=(e=>{const n=new Float32Array([0,0,0,.3,.5,.5]),t=e.createBuffer({size:32,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,mappedAtCreation:!0});return new Float32Array(t.getMappedRange()).set(n),t.unmap(),{buffer:t,edges:{get color(){return n.subarray(0,3)},set color(r){n.set(r),e.queue.writeBuffer(t,0,n,0,3)},get intensity(){return n[3]},set intensity(r){n[3]=r,e.queue.writeBuffer(t,12,n,3,1)},get depthScale(){return n[4]},set depthScale(r){n[4]=r,e.queue.writeBuffer(t,16,n,4,1)},get normalScale(){return n[5]},set normalScale(r){n[5]=r,e.queue.writeBuffer(t,20,n,5,1)}}}})(e),this.geometry=(e=>{const n=e.createBuffer({size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1]),n.unmap(),n})(e),this.pipeline=e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:"\n@vertex\nfn main(@location(0) position : vec4<f32>) -> @builtin(position) vec4<f32> {\n  return position;\n}\n"}),entryPoint:"main",buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]}]},fragment:{module:e.createShaderModule({code:"\nstruct Edges {\n  color : vec3<f32>,\n  intensity : f32,\n  depthScale : f32,\n  normalScale : f32,\n}\n\nstruct Effects {\n  edges : Edges,\n}\n\n@group(0) @binding(0) var<uniform> effects : Effects;\n@group(0) @binding(1) var colorTexture : texture_2d<f32>;\n@group(0) @binding(2) var normalTexture : texture_2d<f32>;\n@group(0) @binding(3) var positionTexture : texture_2d<f32>;\n\nconst offset : vec3<i32> = vec3<i32>(1, 1, 0);\n\nfn edgesDepth(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : f32 = textureLoad(positionTexture, pixel, 0).z;\n  var pixelLeft : f32 = textureLoad(positionTexture, pixel - offset.xz, 0).z;\n  var pixelRight : f32 = textureLoad(positionTexture, pixel + offset.xz, 0).z;\n  var pixelUp : f32 = textureLoad(positionTexture, pixel + offset.zy, 0).z;\n  var pixelDown : f32 = textureLoad(positionTexture, pixel - offset.zy, 0).z;\n  return (\n    abs(pixelLeft    - pixelCenter) \n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter) \n  ) * effects.edges.depthScale;\n}\n\nfn edgesNormal(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : vec3<f32> = textureLoad(normalTexture, pixel, 0).xyz;\n  var pixelLeft : vec3<f32> = textureLoad(normalTexture, pixel - offset.xz, 0).xyz;\n  var pixelRight : vec3<f32> = textureLoad(normalTexture, pixel + offset.xz, 0).xyz;\n  var pixelUp : vec3<f32> = textureLoad(normalTexture, pixel + offset.zy, 0).xyz;\n  var pixelDown : vec3<f32> = textureLoad(normalTexture, pixel - offset.zy, 0).xyz;\n  var edge : vec3<f32> = (\n    abs(pixelLeft    - pixelCenter)\n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter)\n  );\n  return (edge.x + edge.y + edge.z) * effects.edges.normalScale;\n}\n\n@fragment\nfn main(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  var pixel : vec2<i32> = vec2<i32>(floor(uv.xy));\n  var color : vec3<f32> = textureLoad(colorTexture, pixel, 0).xyz;\n  if (effects.edges.intensity != 0) {\n    color = mix(color, effects.edges.color, clamp(max(edgesDepth(pixel), edgesNormal(pixel)), 0, 1) * effects.edges.intensity);\n  }\n  return vec4<f32>(color, 1);\n}\n"}),entryPoint:"main",targets:[{format:n}]},primitive:{topology:"triangle-list"}})}bindTextures({color:e,normal:n,position:t}){const{device:r,effects:o,pipeline:i}=this;this.bindings=r.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:o.buffer}},{binding:1,resource:e},{binding:2,resource:n},{binding:3,resource:t}]})}render(e,n){const{bindings:t,descriptor:r,geometry:o,pipeline:i}=this;r.colorAttachments[0].view=n;const s=e.beginRenderPass(r);s.setPipeline(i),s.setBindGroup(0,t),s.setVertexBuffer(0,o),s.draw(6,1,0,0),s.end()}}const cn=`\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) face : vec4<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) viewPosition: vec3<f32>,\n  @location(1) normal: vec3<f32>,\n  @location(2) uv: vec2<f32>,\n  @location(3) @interpolate(flat) texture: i32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n  normal : mat3x3<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n${sn}\n\nconst faceNormal : vec3<f32> = vec3<f32>(0, 0, 1);\n\n@vertex\nfn main(voxel : VertexInput) -> VertexOutput {\n  var rotation : mat3x3<f32>;\n  switch (i32(voxel.face.w % 6)) {\n    default {\n      rotation = mat3x3<f32>(\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1,\n      );\n    }\n    case 1 {\n      rotation = rotateX(PI * -0.5);\n    }\n    case 2 {\n      rotation = rotateX(PI * 0.5);\n    }\n    case 3 {\n      rotation = rotateY(PI * -0.5);\n    }\n    case 4 {\n      rotation = rotateY(PI * 0.5);\n    }\n    case 5 {\n      rotation = rotateY(PI);\n    }\n  }\n  var mvPosition : vec4<f32> = camera.view * vec4<f32>(rotation * voxel.position + voxel.face.xyz, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.viewPosition = -mvPosition.xyz;\n  out.normal = normalize(camera.normal * rotation * faceNormal);\n  out.uv = voxel.uv;\n  out.texture = i32(floor(voxel.face.w / 6));\n  return out;\n}\n`,ln=e=>{const n=e.createBuffer({size:30*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-.5,-.5,.5,0,1,.5,-.5,.5,1,1,.5,.5,.5,1,0,.5,.5,.5,1,0,-.5,.5,.5,0,0,-.5,-.5,.5,0,1]),n.unmap(),n};class un{constructor({adapter:e,device:n,atlas:t=null,camera:r=null,canvas:o=null,samples:i=4}){const s=navigator.gpu.getPreferredCanvasFormat(e);this.atlas=t||new en({device:n}),this.camera=r||new on({device:n}),this.canvas=o||document.createElement("canvas"),this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight,this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:n,format:s}),this.device=n,this.samples=i;const a=n.createRenderPipeline({layout:"auto",vertex:{module:n.createShaderModule({code:cn}),entryPoint:"main",buffers:[{arrayStride:5*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]},{arrayStride:4*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x4"}]}]},fragment:{module:n.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>,\n  @location(3) @interpolate(flat) texture : i32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) normal : vec4<f32>,\n  @location(2) position : vec4<f32>,\n}\n\n@group(0) @binding(1) var atlas : texture_2d_array<f32>;\n@group(0) @binding(2) var atlasSampler : sampler;\n\n@fragment\nfn main(face : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = textureSample(atlas, atlasSampler, face.uv, face.texture);\n  output.normal = vec4<f32>(normalize(face.normal), 1);\n  output.position = vec4<f32>(face.position, 1);\n  return output;\n}\n"}),entryPoint:"main",targets:[{format:"rgba8unorm"},{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:this.samples}});this.rendering={bindings:n.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.camera.buffer}},{binding:1,resource:this.atlas.texture.createView()},{binding:2,resource:n.createSampler()}]}),descriptor:{colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},geometry:ln(n),pipeline:a},this.postprocessing=new an({device:n,format:s})}render(e,n){const{context:t,postprocessing:r,rendering:{bindings:o,descriptor:i,geometry:s,pipeline:a}}=this,c=e.beginRenderPass(i);c.setPipeline(a),c.setBindGroup(0,o),c.setVertexBuffer(0,s),n.chunks.forEach((({faces:e})=>{c.setVertexBuffer(1,e,16),c.drawIndirect(e,0)})),c.end(),r.render(e,t.getCurrentTexture().createView())}setClearColor(e,n,t){const{rendering:{descriptor:{colorAttachments:[{clearValue:r}]}}}=this;r.r=e,r.g=n,r.b=t}setSize(e,n){const{camera:t,canvas:r,device:o,postprocessing:i,rendering:s,samples:a}=this,c=window.devicePixelRatio||1,l=[Math.floor(e*c),Math.floor(n*c)];r.width=l[0],r.height=l[1],r.style.width=`${e}px`,r.style.height=`${n}px`,t.aspect=e/n,t.updateProjection();const u=(e,n,t,r)=>(e[n]&&e[n].destroy(),e[n]=o.createTexture({size:l,sampleCount:t,format:r,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),e[n].createView());s.descriptor.colorAttachments[0].view=u(s,"colorTexture",a,"rgba8unorm"),s.descriptor.colorAttachments[0].resolveTarget=u(s,"colorTarget",1,"rgba8unorm"),s.descriptor.colorAttachments[1].view=u(s,"normalTexture",a,"rgba16float"),s.descriptor.colorAttachments[1].resolveTarget=u(s,"normalTarget",1,"rgba16float"),s.descriptor.colorAttachments[2].view=u(s,"positionTexture",a,"rgba16float"),s.descriptor.colorAttachments[2].resolveTarget=u(s,"positionTarget",1,"rgba16float"),s.descriptor.depthStencilAttachment.view=u(s,"depthTexture",a,"depth24plus"),i.bindTextures({color:s.colorTarget.createView(),normal:s.normalTarget.createView(),position:s.positionTarget.createView()})}}var fn=({chunkSize:e})=>`\nconst chunkSize : i32 = ${e};\n\nfn getVoxel(pos : vec3<i32>) -> u32 {\n  return u32(pos.z * chunkSize * chunkSize + pos.y * chunkSize + pos.x);\n}\n`;const dn=({chunkSize:e})=>`\nstruct Faces {\n  vertexCount : u32,\n  instanceCount : atomic<u32>,\n  firstVertex : u32,\n  firstInstance : u32,\n  data : array<f32>,\n}\n\n@group(0) @binding(0) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(1) var<storage, read_write> faces : Faces;\n@group(0) @binding(2) var<storage, read> voxels : array<f32>;\n@group(0) @binding(3) var<storage, read> voxels_north : array<f32>;\n@group(0) @binding(4) var<storage, read> voxels_top : array<f32>;\n@group(0) @binding(5) var<storage, read> voxels_bottom : array<f32>;\n@group(0) @binding(6) var<storage, read> voxels_west : array<f32>;\n@group(0) @binding(7) var<storage, read> voxels_east : array<f32>;\n@group(0) @binding(8) var<storage, read> voxels_south : array<f32>;\n\n${fn({chunkSize:e})}\n\nfn isAir(pos : vec3<i32>) -> bool {\n  if (pos.x == -1) {\n    return voxels_west[getVoxel(vec3<i32>(chunkSize - 1, pos.y, pos.z))] == 0;\n  }\n  if (pos.x == chunkSize) {\n    return voxels_east[getVoxel(vec3<i32>(0, pos.y, pos.z))] == 0.0;\n  }\n  if (pos.y == -1) {\n    return voxels_bottom[getVoxel(vec3<i32>(pos.x, chunkSize - 1, pos.z))] == 0;\n  }\n  if (pos.y == chunkSize) {\n    return voxels_top[getVoxel(vec3<i32>(pos.x, 0, pos.z))] == 0;\n  }\n  if (pos.z == -1) {\n    return voxels_south[getVoxel(vec3<i32>(pos.x, pos.y, chunkSize - 1))] == 0;\n  }\n  if (pos.z == chunkSize) {\n    return voxels_north[getVoxel(vec3<i32>(pos.x, pos.y, 0))] == 0;\n  }\n  return voxels[getVoxel(pos)] == 0; \n}\n\nfn pushFace(pos : vec3<i32>, face : i32, texture : i32) {\n  var offset : u32 = atomicAdd(&(faces.instanceCount), 1) * 4;\n  faces.data[offset] = f32(pos.x) + 0.5;\n  faces.data[offset + 1] = f32(pos.y) + 0.5;\n  faces.data[offset + 2] = f32(pos.z) + 0.5;\n  faces.data[offset + 3] = f32(texture * 6 + face);\n}\n\nconst faceNormals = array<vec3<i32>, 6>(\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 1, 0),\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(0, 0, -1),\n);\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize || pos.y >= chunkSize || pos.z >= chunkSize\n  ) {\n    return;\n  }\n  var value : f32 = voxels[getVoxel(pos)];\n  if (value != 0) {\n    var texture : i32 = i32(floor(value) - 1);\n    for (var face : i32 = 0; face < 6; face++) {\n      var npos : vec3<i32> = pos + faceNormals[face];\n      if (isAir(npos)) {\n        pushFace(chunk + pos, face, texture);\n      }\n    }\n  }\n}\n`;class pn{constructor({chunks:e,volume:n}){this.pipeline=n.device.createComputePipeline({layout:"auto",compute:{module:n.device.createShaderModule({code:dn({chunkSize:n.chunkSize})}),entryPoint:"main"}});const t={x:0,y:0,z:0},r=(r,o)=>{if(t.x=r.x+o.x,t.y=r.y+o.y,t.z=r.z+o.z,t.x<0||t.x>=e.x||t.y<0||t.y>=e.y||t.z<0||t.z>=e.z)return n.edge;const i=t.z*e.x*e.y+t.y*e.x+t.x;return n.chunks[i].voxels},o=[{x:0,y:0,z:1},{x:0,y:1,z:0},{x:0,y:-1,z:0},{x:-1,y:0,z:0},{x:1,y:0,z:0},{x:0,y:0,z:-1}];this.bindings=n.chunks.map((e=>({bindings:n.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[e.position,e.faces,e.voxels,...o.map((n=>r(e.chunk,n)))].map(((e,n)=>({binding:n,resource:{buffer:e}})))}),chunk:e}))),this.workgroups=Math.ceil(n.chunkSize/4)}compute(e){const{bindings:n,pipeline:t,workgroups:r}=this;n.forEach((({bindings:n,chunk:o})=>{o.resetInstanceCount(e);const i=e.beginComputePass();i.setPipeline(t),i.setBindGroup(0,n),i.dispatchWorkgroups(r,r,r),i.end()}))}}class vn{constructor({device:e,position:n=new Float32Array([0,0,0]),rotation:t=new Float32Array([0,0,0,1]),scale:r=new Float32Array([1,1,1])}){this.device=e,this.data=Ye(),this.buffer=e.createBuffer({mappedAtCreation:!0,size:this.data.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),je(this.data,t,n,r),new Float32Array(this.buffer.getMappedRange()).set(this.data),this.buffer.unmap()}destroy(){const{buffer:e}=this;e.destroy()}set(e,n,t){const{device:r,buffer:o,data:i}=this;je(i,n,e,t),r.queue.writeBuffer(o,0,i)}}class hn{constructor({geometry:e,volume:n}){const t=e.indices.length/3;this.code=(({chunkSize:e,source:n,triangles:t})=>`\n@group(0) @binding(0) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(1) var<uniform> transform : mat4x4<f32>;\n@group(0) @binding(2) var<storage, read> indices : array<array<u32, 3>>;\n@group(0) @binding(3) var<storage, read> vertices : array<array<f32, 3>>;\n@group(0) @binding(4) var<storage, read_write> voxels : array<f32>;\n\n${fn({chunkSize:e})}\n\nstruct AxisTest {\n  ann : vec3<f32>,\n  fnn : vec3<f32>,\n  aa : i32,\n  bb : i32,\n}\n\nfn intersects(triangle : array<vec3<f32>, 3>, voxel : vec3<f32>) -> bool {\n  var v0 : vec3<f32> = triangle[0] - voxel;\n  var v1 : vec3<f32> = triangle[1] - voxel;\n  var v2 : vec3<f32> = triangle[2] - voxel;\n\n  var f0 : vec3<f32> = v1 - v0;\n  var f1 : vec3<f32> = v2 - v1;\n  var f2 : vec3<f32> = v0 - v2;\n\n  var axis_test = array<AxisTest, 9>(\n    AxisTest(vec3<f32>(0, -f0.z, f0.y), f0, 1, 2),\n    AxisTest(vec3<f32>(0, -f1.z, f1.y), f1, 1, 2),\n    AxisTest(vec3<f32>(0, -f2.z, f2.y), f2, 1, 2),\n    AxisTest(vec3<f32>(f0.z, 0, -f0.x), f0, 0, 2),\n    AxisTest(vec3<f32>(f1.z, 0, -f1.x), f1, 0, 2),\n    AxisTest(vec3<f32>(f2.z, 0, -f2.x), f2, 0, 2),\n    AxisTest(vec3<f32>(-f0.y, f0.x, 0), f0, 0, 1),\n    AxisTest(vec3<f32>(-f1.y, f1.x, 0), f1, 0, 1),\n    AxisTest(vec3<f32>(-f2.y, f2.x, 0), f2, 0, 1),\n  );\n\n  for (var i : i32 = 0; i < 9; i++) {\n    var t : AxisTest = axis_test[i];\n    var p0 : f32 = dot(v0, t.ann);\n    var p1 : f32 = dot(v1, t.ann);\n    var p2 : f32 = dot(v2, t.ann);\n    var r : f32 = 0.5 * abs(t.fnn[t.bb]) + 0.5 * abs(t.fnn[t.aa]);\n    if (max(-max(p0, max(p1, p2)), min(p0, min(p1, p2))) > r) {\n      return false;\n    }\n  }\n\n  if (max(v0.x, max(v1.x, v2.x)) < -0.5 || min(v0.x, min(v1.x, v2.x)) > 0.5) {\n    return false;\n  }\n  if (max(v0.y, max(v1.y, v2.y)) < -0.5 || min(v0.y, min(v1.y, v2.y)) > 0.5) {\n    return false;\n  }\n  if (max(v0.z, max(v1.z, v2.z)) < -0.5 || min(v0.z, min(v1.z, v2.z)) > 0.5) {\n    return false;\n  }\n\n  var planeNorm : vec3<f32> = normalize(cross(f1, f0));\n  var planeConst : f32 = dot(planeNorm, triangle[0]);\n  var r : f32 = 0.5 * abs(planeNorm.x) + 0.5 * abs(planeNorm.y) + 0.5 * abs(planeNorm.z);\n  var s : f32 = abs(dot(planeNorm, voxel) - planeConst);\n  return s <= r;\n}\n\nfn getVertex(index : u32) -> vec3<f32> {\n  var vertex : vec4<f32> = vec4<f32>(vertices[index][0], vertices[index][1], vertices[index][2], 1);\n  return (transform * vertex).xyz - vec3<f32>(chunk);\n}\n\nconst triangles : u32 = ${t};\n\n${n}\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var id : u32 = GlobalInvocationID.x;\n  if (id >= triangles) {\n    return;\n  }\n\n  var triangle = array<vec3<f32>, 3>(\n    getVertex(indices[id][0]),\n    getVertex(indices[id][1]),\n    getVertex(indices[id][2]),\n  );\n\n  var tmin : vec3<i32> = vec3<i32>(chunkSize);\n  var tmax : vec3<i32> = vec3<i32>(0);\n  for (var i : i32 = 0; i < 3; i++) {\n    var p = vec3<i32>(triangle[i]);\n    tmin = min(tmin, p);\n    tmax = max(tmax, p);\n  }\n  tmin = clamp(tmin, vec3<i32>(0), vec3<i32>(chunkSize - 1));\n  tmax = clamp(tmax, vec3<i32>(0), vec3<i32>(chunkSize - 1));\n\n  for (var z : i32 = tmin.z; z <= tmax.z; z++) {\n    for (var y : i32 = tmin.y; y <= tmax.y; y++) {\n      for (var x : i32 = tmin.x; x <= tmax.x; x++) {\n        if (intersects(triangle, vec3<f32>(f32(x) + 0.5, f32(y) + 0.5, f32(z) + 0.5))) {\n          var pos : vec3<i32> = vec3<i32>(x, y, z);\n          voxels[getVoxel(pos)] = getValueAt(vec3<f32>(chunk + pos));\n        }\n      }\n    }\n  }\n}\n`)({chunkSize:n.chunkSize,source:e.source||"\nfn getValueAt(pos : vec3<f32>) -> f32 {\n  return 1;\n}\n",triangles:t}),this.shader=n.device.createShaderModule({code:this.code}),this.pipeline=n.device.createComputePipeline({layout:"auto",compute:{module:this.shader,entryPoint:"main"}}),this.transform=new vn({device:n.device,position:e.position,rotation:e.rotation,scale:e.scale}),this.indices=n.device.createBuffer({mappedAtCreation:!0,size:e.indices.byteLength,usage:GPUBufferUsage.STORAGE}),new Uint32Array(this.indices.getMappedRange()).set(e.indices),this.indices.unmap(),this.vertices=n.device.createBuffer({mappedAtCreation:!0,size:e.vertices.byteLength,usage:GPUBufferUsage.STORAGE}),new Float32Array(this.vertices.getMappedRange()).set(e.vertices),this.vertices.unmap(),this.bindings=n.chunks.map((({position:e,voxels:t})=>({bindings:n.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[e,this.transform.buffer,this.indices,this.vertices,t].map(((e,n)=>({binding:n,resource:{buffer:e}})))}),clearChunk:e=>e.clearBuffer(t)}))),this.workgroups=Math.ceil(t/64)}compute(e){const{bindings:n,pipeline:t,workgroups:r}=this;n.forEach((({bindings:n,clearChunk:o})=>{o(e);const i=e.beginComputePass();i.setPipeline(t),i.setBindGroup(0,n),i.dispatchWorkgroups(r),i.end()}))}destroy(){const{transform:e,indices:n,vertices:t}=this;e.destroy(),n.destroy(),t.destroy()}}class gn{constructor({source:e,volume:n}){this.code=(({chunkSize:e,width:n,height:t,depth:r,source:o})=>`\n@group(0) @binding(0) var<uniform> time : f32;\n@group(0) @binding(1) var<uniform> chunk : vec3<i32>;\n@group(0) @binding(2) var<storage, read_write> voxels : array<f32>;\n\n${Qe}\n${sn}\nfn sdBox(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var q : vec3<f32> = abs(p) - r;\n  return length(max(q, vec3<f32>(0))) + min(max(q.x, max(q.y, q.z)), 0);\n}\n\nfn sdCapsule(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var q : vec3<f32> = vec3<f32>(p.x, clamp(p.y, -r.y + r.x, r.y - r.x), p.y);\n  return length(q) - q.x;\n}\n\nfn sdEllipsoid(p : vec3<f32>, r : vec3<f32>) -> f32 {\n  var k0 : f32 = length(p / r);\n  var k1 : f32 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1;\n}\n\nfn sdSphere(p : vec3<f32>, r : f32) -> f32 {\n  return length(p) - r;\n}\n\nfn sdTorus(p : vec3<f32>, r : vec2<f32>) -> f32 {\n  var q : vec2<f32> = vec2<f32>(length(p.xz) - r.x, p.y);\n  return length(q) - r.y;\n}\n\nfn opUnion(d1 : f32, d2 : f32) -> f32 {\n  return min(d1, d2);\n}\n\nfn opSubstraction(d1 : f32, d2 : f32) -> f32 {\n  return max(d1, -d2);\n}\n\nfn opSmoothUnion(d1 : f32, d2 : f32, k : f32) -> f32 {\n  var h : f32 = clamp(0.5 + 0.5 * (d2 - d1) / k, 0, 1);\n  return mix(d2, d1, h) + k * h * (1 - h);\n}\n\nfn opSmoothSubstraction(d1 : f32, d2 : f32, k : f32) -> f32 {\n  var h : f32 = clamp(0.5 - 0.5 * (d2 + d1) / k, 0, 1);\n  return mix(d1, -d2, h) + k * h * (1 - h);\n}\n\n${fn({chunkSize:e})}\n\nstruct Volume {\n  center : vec3<f32>,\n  size : vec3<f32>,\n}\n\nconst volume : Volume = Volume(\n  vec3<f32>(${.5*n}, ${.5*t}, ${.5*r}),\n  vec3<f32>(${n}, ${t}, ${r})\n);\n\n${o}\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize || pos.y >= chunkSize || pos.z >= chunkSize\n  ) {\n    return;\n  }\n  voxels[getVoxel(pos)] = getValueAt(vec3<f32>(chunk + pos));\n}\n`)({chunkSize:n.chunkSize,width:n.width,height:n.height,depth:n.depth,source:e}),this.shader=n.device.createShaderModule({code:this.code}),this.pipeline=n.device.createComputePipeline({layout:"auto",compute:{module:this.shader,entryPoint:"main"}}),this.bindings=n.chunks.map((({position:e,voxels:t})=>n.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[n.time.buffer,e,t].map(((e,n)=>({binding:n,resource:{buffer:e}})))}))),this.workgroups=Math.ceil(n.chunkSize/4)}compute(e){const{bindings:n,pipeline:t,workgroups:r}=this;n.forEach((n=>{const o=e.beginComputePass();o.setPipeline(t),o.setBindGroup(0,n),o.dispatchWorkgroups(r,r,r),o.end()}))}}class mn{constructor({device:e,chunk:n,chunkSize:t}){this.chunk=n,this.faces=e.createBuffer({mappedAtCreation:!0,size:4*Uint32Array.BYTES_PER_ELEMENT+6*Math.ceil(t*t*t*.5)*4*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),new Uint32Array(this.faces.getMappedRange())[0]=6,this.faces.unmap(),this.position=e.createBuffer({mappedAtCreation:!0,size:3*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM}),new Int32Array(this.position.getMappedRange()).set([n.x*t,n.y*t,n.z*t]),this.position.unmap(),this.voxels=mn.createVoxelsBuffer({device:e,chunkSize:t})}destroy(){const{faces:e,position:n,voxels:t}=this;e.destroy(),n.destroy(),t.destroy()}resetInstanceCount(e){const{faces:n}=this;e.clearBuffer(n,4,4)}static createVoxelsBuffer({device:e,chunkSize:n}){return e.createBuffer({size:n*n*n*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE})}}class xn{constructor({device:e}){this.device=e,this.data=new Float32Array(1),this.buffer=e.createBuffer({size:this.data.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM})}destroy(){const{buffer:e}=this;e.destroy()}set(e){const{device:n,buffer:t,data:r}=this;r[0]=e,n.queue.writeBuffer(t,0,r)}}class yn{constructor({chunkSize:e=100,device:n,width:t,height:r,depth:o}){this.chunkSize=e,this.device=n,this.width=t,this.height=r,this.depth=o;const i={x:Math.ceil(t/e),y:Math.ceil(r/e),z:Math.ceil(o/e)};this.chunks=[];for(let t=0;t<i.z;t++)for(let r=0;r<i.y;r++)for(let o=0;o<i.x;o++)this.chunks.push(new mn({device:n,chunk:{x:o,y:r,z:t},chunkSize:e}));this.edge=mn.createVoxelsBuffer({device:n,chunkSize:e}),this.mesher=new pn({chunks:i,volume:this}),this.time=new xn({device:n})}compute(e,n){const{mesher:t,time:r,voxelizer:o}=this;r.set(n),o.compute(e),t.compute(e)}destroy(){const{chunks:e,edge:n,time:t,voxelizer:r}=this;e.forEach((e=>e.destroy())),n.destroy(),t.destroy(),r&&r.destroy&&r.destroy()}setScene(e){const{voxelizer:n}=this;n&&n.destroy&&n.destroy(),e.geometry?this.voxelizer=new hn({geometry:e.geometry,volume:this}):e.source&&(this.voxelizer=new gn({source:e.source,volume:this}))}}class bn{constructor(e){this.look={state:Je(.5*Math.PI,0),target:Je(.5*Math.PI,0)},this.pointer={movement:He(),position:He()},this.zoom={state:.75,target:.75},this.target=e,this.updateBounds(),this.onMouseDown=this.onMouseDown.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onMouseWheel=this.onMouseWheel.bind(this),e.addEventListener("mousedown",this.onMouseDown,!1),window.addEventListener("mousemove",this.onMouseMove,!1),window.addEventListener("mouseup",this.onMouseUp,!1),window.addEventListener("wheel",this.onMouseWheel,{passive:!1})}destroy(){this.target.removeEventListener("mousedown",this.onMouseDown),window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("mouseup",this.onMouseUp),window.removeEventListener("wheel",this.onMouseWheel)}onMouseDown({button:e}){const{pointer:n}=this;n.isDown=0===e}onMouseMove({clientX:e,clientY:n,movementX:t,movementY:r}){const{sensitivity:o}=bn,{bounds:i,pointer:{movement:s,position:a}}=this;s[0]-=t*o.look,s[1]-=r*o.look,Ke(a,(e-i.x)/i.width*2-1,-(n-i.y)/i.height*2+1)}onMouseUp({button:e}){const{pointer:n}=this;0===e&&(n.isDown=!1)}onMouseWheel(e){e.ctrlKey&&e.preventDefault();const{sensitivity:n,minZoom:t,zoomRange:r}=bn,{zoom:o}=this,i=Math.min(Math.max((Math.log(o.target)-t)/r+e.deltaY*n.zoom,0),1);o.target=Math.exp(t+i*r)}update(e){const{minPhi:n,maxPhi:t}=bn,{pointer:r,look:o,zoom:i}=this;r.isDown&&(o.target[1]+=r.movement[0],o.target[0]=Math.min(Math.max(o.target[0]+r.movement[1],n),t));const s=1-Math.exp(-10*e);!function(e,n,t,r){var o=n[0],i=n[1];e[0]=o+r*(t[0]-o),e[1]=i+r*(t[1]-i)}(o.state,o.state,o.target,s),i.state=i.state*(1-s)+i.target*s,Ke(r.movement,0,0)}updateBounds(){const{target:e}=this;this.bounds=e.getBoundingClientRect()}}function wn(n){let t;return{c(){t=y("div"),k(t,"class","viewport svelte-vo8in0")},m(e,r){g(e,t,r),n[1](t)},p:e,i:e,o:e,d(e){e&&m(t),n[1](null)}}}function zn(e,n,t){const r=e=>[parseInt(e.slice(1,3),16)/255,parseInt(e.slice(3,5),16)/255,parseInt(e.slice(5,7),16)/255];let o;return C((()=>{const e=new bn(o),n=new un(ae.gpu);o.appendChild(n.canvas),n.setSize(window.innerWidth,window.innerHeight),n.setSize(e.bounds.width,e.bounds.height),window.addEventListener("resize",(()=>{e.updateBounds(),n.setSize(e.bounds.width,e.bounds.height)}),!1);let t,i=performance.now()/1e3,s=!1;const a=()=>{requestAnimationFrame(a);const r=performance.now()/1e3,o=r-i;if(i=r,e.update(o),n.camera.setOrbit(e.look.state[0],e.look.state[1],t.width*e.zoom.state),s)return;const c=n.device.createCommandEncoder();t.compute(c,r),n.render(c,t),n.device.queue.submit([c.finish()])};requestAnimationFrame(a);const c=({code:e,shader:n},t)=>{s=!1;const r=e.split("\n"),o=r.indexOf("// __SOURCE__")+1;n.compilationInfo().then((({messages:e})=>t.set(e.map((({length:e,lineNum:n,linePos:t,message:i,type:a})=>(s=!0,{line:r[n-1],lineNum:n-o,linePos:t,length:e,message:i,pointer:Array.from({length:t-1+e},((e,n)=>n>=t-1?"^":" ")).join(""),type:a}))))))},l=[ie.source.subscribe((e=>{e="// __SOURCE__\n"+e,n.atlas.compute(e),c(n.atlas,ie.errors)})),ae.background.subscribe((e=>n.setClearColor(...r(e)))),ae.effects.edges.color.subscribe((e=>{n.postprocessing.effects.edges.color=r(e)})),ae.effects.edges.intensity.subscribe((e=>{n.postprocessing.effects.edges.intensity=e})),ae.resolution.subscribe((e=>{let r;t&&(r=t.source,t.destroy()),t=new yn({device:n.device,width:e,height:e,depth:e}),r&&(t.source=r,t.setScene({source:r})),Ze(n.camera.target,.5*t.width,.5*t.height,.5*t.depth)})),ce.source.subscribe((e=>{t.source=e,e="// __SOURCE__\n"+e,t.setScene({source:e}),c(t.voxelizer,ce.errors)}))];return()=>{l.forEach((e=>e())),e.destroy(),t.destroy()}})),[o,function(e){B[e?"unshift":"push"]((()=>{o=e,t(0,o)}))}]}bn.sensitivity={look:.003,zoom:3e-4},bn.minPhi=1e-6,bn.maxPhi=Math.PI-1e-6,bn.minZoom=Math.log(.25),bn.maxZoom=Math.log(1.5),bn.zoomRange=bn.maxZoom-bn.minZoom;class kn extends te{constructor(e){super(),ne(this,e,zn,wn,i,{})}}const{window:$n}=J;function Sn(e){let n,t;return n=new ze({}),{c(){K(n.$$.fragment)},m(e,r){Q(n,e,r),t=!0},i(e){t||(Z(n.$$.fragment,e),t=!0)},o(e){H(n.$$.fragment,e),t=!1},d(e){ee(n,e)}}}function En(e){let n,t;return n=new me({}),{c(){K(n.$$.fragment)},m(e,r){Q(n,e,r),t=!0},i(e){t||(Z(n.$$.fragment,e),t=!0)},o(e){H(n.$$.fragment,e),t=!1},d(e){ee(n,e)}}}function Mn(e){let n,t;return n=new $e({}),{c(){K(n.$$.fragment)},m(e,r){Q(n,e,r),t=!0},i(e){t||(Z(n.$$.fragment,e),t=!0)},o(e){H(n.$$.fragment,e),t=!1},d(e){ee(n,e)}}}function Tn(e){let n,t,o,i,s,a,c,l,u,f,d,p,v;o=new Ne({});const x=[Mn,En,Sn],b=[];function $(e,n){return"scene"===e[1]?0:"atlas"===e[1]?1:"rendering"===e[1]?2:-1}return~(s=$(e))&&(a=b[s]=x[s](e)),f=new kn({}),{c(){n=y("div"),t=y("div"),K(o.$$.fragment),i=w(),a&&a.c(),c=w(),l=y("div"),u=w(),K(f.$$.fragment),k(t,"class","ui svelte-efpout"),M(t,"width",e[0]+"px"),k(l,"class","divider svelte-efpout"),k(n,"class","app svelte-efpout")},m(r,a){g(r,n,a),h(n,t),Q(o,t,null),h(t,i),~s&&b[s].m(t,null),h(n,c),h(n,l),h(n,u),Q(f,n,null),d=!0,p||(v=[z($n,"mousemove",e[3]),z($n,"mouseup",e[4]),z(l,"mousedown",e[2])],p=!0)},p(e,[n]){let r=s;s=$(e),s!==r&&(a&&(X(),H(b[r],1,1,(()=>{b[r]=null})),W()),~s?(a=b[s],a||(a=b[s]=x[s](e),a.c()),Z(a,1),a.m(t,null)):a=null),(!d||1&n)&&M(t,"width",e[0]+"px")},i(e){d||(Z(o.$$.fragment,e),Z(a),Z(f.$$.fragment,e),d=!0)},o(e){H(o.$$.fragment,e),H(a),H(f.$$.fragment,e),d=!1},d(e){e&&m(n),ee(o),~s&&b[s].d(),ee(f),p=!1,r(v)}}}function _n(e,n,t){let r;c(e,le,(e=>t(1,r=e)));let o=800;const i={enabled:!1,initial:0,offset:0};return[o,r,({clientX:e})=>{i.enabled=!0,i.initial=o,i.offset=e},({clientX:e})=>{i.enabled&&(t(0,o=Math.max(Math.floor(i.initial+e-i.offset),500)),V().then((()=>window.dispatchEvent(new Event("resize")))))},()=>{i.enabled&&(i.enabled=!1)}]}class Pn extends te{constructor(e){super(),ne(this,e,_n,Tn,i,{})}}function Cn(e){let n,t;return n=new Pn({}),{c(){K(n.$$.fragment)},m(e,r){Q(n,e,r),t=!0},i(e){t||(Z(n.$$.fragment,e),t=!0)},o(e){H(n.$$.fragment,e),t=!1},d(e){ee(n,e)}}}function An(n){let t;return{c(){t=y("div"),t.innerHTML='Sorry! This works only in <a href="https://www.google.com/chrome/canary/" rel="noopener noreferrer" target="_blank" class="svelte-4omflb">Chrome Canary</a>.',k(t,"class","canary svelte-4omflb")},m(e,n){g(e,t,n)},i:e,o:e,d(e){e&&m(t)}}}function Bn(n){let t;return{c(){t=y("div"),t.textContent="Loading...",k(t,"class","loading svelte-4omflb")},m(e,n){g(e,t,n)},i:e,o:e,d(e){e&&m(t)}}}function Un(e){let n,t,r,o,i,s,a;const c=[Bn,An,Cn],l=[];function u(e,n){return e[1]?0:e[0]?1:2}return n=u(e),t=l[n]=c[n](e),{c(){t.c(),r=w(),o=y("div"),o.innerHTML='voxeltoy - <a href="https://github.com/danielesteban/voxeltoy" rel="noopener noreferrer" target="_blank" class="svelte-4omflb">view source</a><br/> \n  <a href="https://dani.gatunes.com" rel="noopener noreferrer" target="_blank" class="svelte-4omflb">dani@gatunes</a> © 2022',i=w(),s=y("a"),s.textContent="♥ Become a sponsor",k(o,"class","info svelte-4omflb"),k(s,"class","ribbon svelte-4omflb"),k(s,"href","https://github.com/sponsors/danielesteban"),k(s,"data-ribbon","♥ Become a sponsor"),k(s,"rel","noopener noreferrer"),k(s,"target","_blank")},m(e,t){l[n].m(e,t),g(e,r,t),g(e,o,t),g(e,i,t),g(e,s,t),a=!0},p(e,[o]){let i=n;n=u(e),n!==i&&(X(),H(l[i],1,1,(()=>{l[i]=null})),W(),t=l[n],t||(t=l[n]=c[n](e),t.c()),Z(t,1),t.m(r.parentNode,r))},i(e){a||(Z(t),a=!0)},o(e){H(t),a=!1},d(e){l[n].d(e),e&&m(r),e&&m(o),e&&m(i),e&&m(s)}}}function Ln(e,n,t){let r=!1,o=!0;return Promise.all([(async()=>{if(!navigator.gpu||!navigator.gpu.getPreferredCanvasFormat)throw new Error("WebGPU");const e=await navigator.gpu.requestAdapter(),n=await e.requestDevice();return{adapter:e,device:n}})(),new Promise((e=>{require.config({paths:{vs:"https://cdn.jsdelivr.net/npm/monaco-editor@0.33.0/min/vs"}}),require(["vs/editor/editor.main"],e)}))]).then((([e])=>{ae.gpu=e})).catch((e=>{console.error(e),t(0,r=!0)})).finally((()=>{t(1,o=!1)})),[r,o]}new class extends te{constructor(e){super(),ne(this,e,Ln,Un,i,{})}}({target:document.body})}();
